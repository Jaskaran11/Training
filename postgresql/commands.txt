What is a Database?
A database is information that is set up for easy access, management and updating.Databases are used for storing, maintaining and accessing any sort of data. They collect information on people, places or things. That information is gathered in one place so that it can be observed and analyzed. Databases can be thought of as an organized collection of information.

PostgreSql-
It is a powerful, open source object-relational database system.PostgreSQL runs on all major operating systems.PostgreSQL supports a large part of the SQL standard.
It is a highly stable database management system, backed by more than 20 years of community development which has contributed to its high levels of resilience, integrity, and correctness.
It uses the SQL language.

Commands in postgresql-
The DDL (Data Definition Language) commands are used to define the database. Example: CREATE, DROP, ALTER, TRUNCATE, COMMENT, RENAME.
The DML (Data Manipulation Language) commands deal with the manipulation of data present in the database. Example: SELECT, INSERT, UPDATE, DELETE.
The DCL (Data Control Language) commands deal with the permissions, rights and other controls of the database system. Example: GRANT, INVOKE.
The TCL (Transaction Control Language) commands deal with the transaction of the database.Example: BEGIN, COMMIT, ROLLBACK.


postgres=# select version();
                          version
------------------------------------------------------------
 PostgreSQL 14.2, compiled by Visual C++ build 1914, 64-bit
(1 row)

postgres-# \l
                                         List of databases
   Name    |  Owner   | Encoding |      Collate       |       Ctype        |   Access privileges
-----------+----------+----------+--------------------+--------------------+-----------------------
 postgres  | postgres | UTF8     | English_India.1252 | English_India.1252 |
 template0 | postgres | UTF8     | English_India.1252 | English_India.1252 | =c/postgres          +
           |          |          |                    |                    | postgres=CTc/postgres
 template1 | postgres | UTF8     | English_India.1252 | English_India.1252 | =c/postgres          +
           |          |          |                    |                    | postgres=CTc/postgres
(3 rows)


postgres=# create database test;
CREATE DATABASE

test-#
Here # shows I am Super User
test=>
" => " have rights to the database

postgres-# \?
General
  \copyright             show PostgreSQL usage and distribution terms
  \crosstabview [COLUMNS] execute query and display results in crosstab
  \errverbose            show most recent error message at maximum verbosity
  \g [(OPTIONS)] [FILE]  execute query (and send results to file or |pipe);
                         \g with no arguments is equivalent to a semicolon
  \gdesc                 describe result of query, without executing it
  \gexec                 execute query, then execute each value in its result
  \gset [PREFIX]         execute query and store results in psql variables
  \gx [(OPTIONS)] [FILE] as \g, but forces expanded output mode
  \q                     quit psql
  \watch [SEC]           execute query every SEC seconds

Help
  \? [commands]          show help on backslash commands
  \? options             show help on psql command-line options
  \? variables           show help on special variables
  \h [NAME]              help on syntax of SQL commands, * for all commands

Query Buffer
  \e [FILE] [LINE]       edit the query buffer (or file) with external editor
  \ef [FUNCNAME [LINE]]  edit function definition with external editor
  \ev [VIEWNAME [LINE]]  edit view definition with external editor
  \p                     show the contents of the query buffer
  \r                     reset (clear) the query buffer
  \w FILE                write query buffer to file

Input/Output
  \copy ...              perform SQL COPY with data stream to the client host
-- More  --


#To see current date
# select current_date;
 current_date
--------------
 2022-04-01


#running an arithmetic operation
postgres=# select 2+2;
 ?column?
----------
        4
(1 row)

#to permanently delete a database;
 drop database test1;
DROP DATABASE

#to change database
test=# \c test1;
You are now connected to database "test1" as user "postgres".


Table synatx - 

CREATE TABLE table_name(
Column name + data type + constraints if any
)

test=# create table person (
test(# id int not null primary key,
test(# first_name varchar(50) not null,
test(# last_name varchar(50) not null,
test(# gender varchar(7) not null,
test(# date_of_birth date not null,
test(# email varchar(150)  );
CREATE TABLE


#to view table
test=# \d
         List of relations
 Schema |  Name  | Type  |  Owner
--------+--------+-------+----------
 public | person | table | postgres
(1 row)



test=# \d person;
                          Table "public.person"
    Column     |          Type          | Collation | Nullable | Default
---------------+------------------------+-----------+----------+---------
 id            | integer                |           | not null |
 first_name    | character varying(50)  |           | not null |
 last_name     | character varying(50)  |           | not null |
 gender        | character varying(7)   |           | not null |
 date_of_birth | date                   |           | not null |
 email         | character varying(150) |           |          |
Indexes:
    "person_pkey" PRIMARY KEY, btree (id)


#to delete a table
test=# drop table person;
DROP TABLE


test=# \dt
         List of relations
 Schema |  Name  | Type  |  Owner
--------+--------+-------+----------
 public | person | table | postgres
(1 row)


#inserting values into table

test=# insert into person (id, first_name, last_name, gender, date_of_birth)
test-# values(1,'John','Smith','Male',date '2000-11-04');
INSERT 0 1
test=# insert into person (id, first_name,last_name, gender, date_of_birth, email)
test-# values(2,'Jessica','Jones','Female',date '1999-05-05','jessica@gmail.com');
INSERT 0 1
test=# insert into person (id,first_name,last_name,gender,date_of_birth,email)
test-# values(3,'David','Ayers','Male',date '1999=06-07','david@gmail.com');
INSERT 0 1
test=# insert into person (id,first_name,last_name,gender,date_of_birth,email)
test-# values(4,'Chris','Evans','Male',date '1998-07-11','chris@gmail.com');
INSERT 0 1
test=# insert into person (id,first_name,last_name,gender,date_of_birth,email)
test-# values(5,'Hela','Ray','Female',date '1996-09-12','hela@gmail.com');
INSERT 0 1


 SELECT statement is used to fetch the data from a database table,
test=# select * from person;
 id | first_name | last_name | gender | date_of_birth |       email
----+------------+-----------+--------+---------------+-------------------
  1 | John       | Smith     | Male   | 2000-11-04    | john@gmail.com
  2 | Jessica    | Jones     | Female | 1999-05-05    | jessica@gmail.com
  3 | David      | Ayers     | Male   | 1999-06-07    | david@gmail.com
  4 | Chris      | Evans     | Male   | 1998-07-11    | chris@gmail.com
  5 | Hela       | Ray       | Female | 1996-09-12    | hela@gmail.com
(5 rows)


test=# select first_name, last_name from person;
 first_name | last_name
------------+-----------
 John       | Smith
 Jessica    | Jones
 David      | Ayers
 Chris      | Evans
 Hela       | Ray
(5 rows)


test=# select * from person order by first_name;
 id | first_name | last_name | gender | date_of_birth |       email
----+------------+-----------+--------+---------------+-------------------
  4 | Chris      | Evans     | Male   | 1998-07-11    | chris@gmail.com
  3 | David      | Ayers     | Male   | 1999-06-07    | david@gmail.com
  5 | Hela       | Ray       | Female | 1996-09-12    | hela@gmail.com
  2 | Jessica    | Jones     | Female | 1999-05-05    | jessica@gmail.com
  1 | John       | Smith     | Male   | 2000-11-04    | john@gmail.com
(5 rows)



test=# select * from person order by id DESC;
 id | first_name | last_name | gender | date_of_birth |       email
----+------------+-----------+--------+---------------+-------------------
  5 | Hela       | Ray       | Female | 1996-09-12    | hela@gmail.com
  4 | Chris      | Evans     | Male   | 1998-07-11    | chris@gmail.com
  3 | David      | Ayers     | Male   | 1999-06-07    | david@gmail.com
  2 | Jessica    | Jones     | Female | 1999-05-05    | jessica@gmail.com
  1 | John       | Smith     | Male   | 2000-11-04    | john@gmail.com
(5 rows)



test=# select * from person where gender='Female';
 id | first_name | last_name | gender | date_of_birth |       email
----+------------+-----------+--------+---------------+-------------------
  2 | Jessica    | Jones     | Female | 1999-05-05    | jessica@gmail.com
  5 | Hela       | Ray       | Female | 1996-09-12    | hela@gmail.com



test=# SELECT 1<2;
 ?column?
----------
 t
(1 row)

 Select * from person where last_name in ('Jones','Evans','Ray');
 id | first_name | last_name | gender | date_of_birth |       email
----+------------+-----------+--------+---------------+-------------------
  2 | Jessica    | Jones     | Female | 1999-05-05    | jessica@gmail.com
  4 | Chris      | Evans     | Male   | 1998-07-11    | chris@gmail.com
  5 | Hela       | Ray       | Female | 1996-09-12    | hela@gmail.com
(3 rows)




WHERE CLAUSE - used to specify a condition while fetching the data from single table or joining with multiple tables.

syntax:SELECT column1, column2, columnN
                             FROM table_name
                             WHERE [search_condition]
test=# select * from person where first_name like 'J%';
 id | first_name | last_name | gender | date_of_birth |       email
----+------------+-----------+--------+---------------+-------------------
  1 | John       | Smith     | Male   | 2000-11-04    | john@gmail.com
  2 | Jessica    | Jones     | Female | 1999-05-05    | jessica@gmail.com
(2 rows)



test=# create table company (
test(# id int not null primary key,
test(# name varchar(55) not null,
test(# age int not null,
test(# address varchar(55) not null,
test(# salary int not null,
test(# join_date date not null );
CREATE TABLE
test=# \d
          List of relations
 Schema |  Name   | Type  |  Owner
--------+---------+-------+----------
 public | company | table | postgres
 public | person  | table | postgres
 public | teacher | table | postgres
(3 rows)


test=# insert into company (id,name,age,address,salary,join_date)
test-# values(1,'Paul',23,'Texas',10000,'2001-07-13'),
test-# (2,'Rahul',34,'California',85000,'2007-08-11'),
test-# (3,'Nitin',33,'Rich-Mond',45000,'2010-12-13'),
test-# (4,'Joe',45,'Texas',90000,'2000-11-05');
INSERT 0 4
test=# select * from company;
 id | name  | age |  address   | salary | join_date
----+-------+-----+------------+--------+------------
  1 | Paul  |  23 | Texas      |  10000 | 2001-07-13
  2 | Rahul |  34 | California |  85000 | 2007-08-11
  3 | Nitin |  33 | Rich-Mond  |  45000 | 2010-12-13
  4 | Joe   |  45 | Texas      |  90000 | 2000-11-05
(4 rows)

select * from company where age>=25 or salary>=65000;
 id | name  | age |  address   | salary | join_date
----+-------+-----+------------+--------+------------
  2 | Rahul |  34 | California |  85000 | 2007-08-11
  3 | Nitin |  33 | Rich-Mond  |  45000 | 2010-12-13
  4 | Joe   |  45 | Texas      |  90000 | 2000-11-05
(3 rows)




#Update query with where clause;
                 
                  syntax:UPDATE table_name
                  SET column1 = value1, column2 = value2...., columnN = valueN
                  WHERE [condition];

update company set join_date = '2002-07-03' where id=3;
UPDATE 1
test=# select * from company;
 id | name  | age |  address   | salary | join_date
----+-------+-----+------------+--------+------------
  1 | Paul  |  23 | Texas      |  10000 | 2001-07-13
  2 | Rahul |  34 | California |  85000 | 2007-08-11
  4 | Joe   |  45 | Texas      |  90000 | 2000-11-05
  3 | Nitin |  33 | Rich-Mond  |  45000 | 2002-07-03
(4 rows)


 #Delete query 

          syntax: DELETE FROM table_name  WHERE condition;
           delete from company where id=2;

 id | name  | age |  address  | salary | join_date
----+-------+-----+-----------+--------+------------
  1 | Paul  |  23 | Texas     |  10000 | 2001-07-13
  4 | Joe   |  45 | Texas     |  90000 | 2000-11-05
  3 | Nitin |  33 | Rich-Mond |  45000 | 2002-07-03


#ORDER by:ORDER BY clause is used to sort the data in ascending or descending order.
              
                   syntax:SELECT column-list
                          FROM table_name
                          [WHERE condition]
                          [ORDER BY column1, column2, .. columnN] [ASC | DESC];

                    test=# select * from company order by name, salary asc;
 id | name  | age |  address  | salary | join_date
----+-------+-----+-----------+--------+------------
  4 | Joe   |  45 | Texas     |  90000 | 2000-11-05
  3 | Nitin |  33 | Rich-Mond |  45000 | 2002-07-03
  1 | Paul  |  23 | Texas     |  10000 | 2001-07-13


29.GROUP BY: GROUP BY clause is used in collaboration with the SELECT statement to group together those rows in a table that have identical data.

                                        syntax:SELECT column-list
                                               FROM table_name
                                               WHERE [ conditions ]
                                               GROUP BY column1, column2....columnN
                                               ORDER BY column1, column2....columnN
                                         test=# select address, count(*) from company group by address;
  address  | count
-----------+-------
 Rich-Mond |     1
 Texas     |     2
(2 rows)


#Views in SQL are kind of virtual tables. A view also has rows and columns as they are in a real table in the database.

The basic CREATE VIEW syntax is as follows −

CREATE [TEMP | TEMPORARY] VIEW view_name AS
SELECT column1, column2.....
FROM table_name
WHERE [condition];



test=# create VIEW myview as
test-# select name,age,address,salary
test-# from company;
CREATE VIEW

       ^
test=#  select * from myview;
 name  | age |  address  | salary
-------+-----+-----------+--------
 Paul  |  23 | Texas     |  10000
 Joe   |  45 | Texas     |  90000
 Nitin |  33 | Rich-Mond |  45000
(3 rows)


#to drop a view-
test=# drop view myview;
DROP VIEW

#primary key-A primary key is a column or a group of columns used to identify a row uniquely in a table.

test=# insert into person(id,first_name,last_name,gender,date_of_birth,email) values (1,'John','Smith','Male','2000-11-04','john@gmail.com');
ERROR:  duplicate key value violates unique constraint "person_pkey"
DETAIL:  Key (id)=(1) already exists.

to remove the primary key
test=# ALTER TABLE person DROP CONSTRAINT person_pkey;
ALTER TABLE

to add the primary key
 ALTER TABLE person ADD PRIMARY KEY (id);
ALTER TABLE

#Unique Constraints - A UNIQUE CONSTRAINT is used to maintain the individuality of the values that we store into a field or a column of the table. 
It is compatible with a group of column constraints or column constraints and a table constraint.

test=# ALTER TABLE person ADD CONSTRAINT unique_email_address UNIQUE (email);
ALTER TABLE

test=# \d person;
                          Table "public.person"
    Column     |          Type          | Collation | Nullable | Default
---------------+------------------------+-----------+----------+---------
 id            | integer                |           | not null |
 first_name    | character varying(50)  |           | not null |
 last_name     | character varying(50)  |           | not null |
 gender        | character varying(7)   |           | not null |
 date_of_birth | date                   |           | not null |
 email         | character varying(150) |           |          |
Indexes:
    "person_pkey" PRIMARY KEY, btree (id)
    "unique_email_address" UNIQUE CONSTRAINT, btree (email)


#A foreign key constraint specifies that the values in a column (or a group of columns) must match the values appearing in some row of another table. 
It maintains the referential integrity between two related tables. 
They are called foreign keys because the constraints are foreign; that is, outside the table.
                   ^
test=# create table company1(
test(# id int primary key not null,
test(# name varchar(50) not null,
test(# age int not null,
test(# address varchar(50),
test(# salary int
test(# );
CREATE TABLE


test=# create table department1(
test(# id int primary key not null,
test(# dept varchar(50) not null,
test(# emp_id int references company1(id)
test(# );
CREATE TABLE
test=# select * from department1;
 id | dept | emp_id
----+------+--------
(0 rows)


test=# \d department1;
                   Table "public.department1"
 Column |         Type          | Collation | Nullable | Default
--------+-----------------------+-----------+----------+---------
 id     | integer               |           | not null |
 dept   | character varying(50) |           | not null |
 emp_id | integer               |           |          |
Indexes:
    "department1_pkey" PRIMARY KEY, btree (id)
Foreign-key constraints:
    "department1_emp_id_fkey" FOREIGN KEY (emp_id) REFERENCES company1(id)



# Transactions
It is fundamental concept of Database systems.
It bundles multiple steps into one for all or nothing operation.
it help to provide atomicity propertty of datatbase ie if some failure occurs that prevents the transaction from completing, then none of the steps affect the database at all
A transactional database guarantees that all the updates made by a transaction are logged in permanent storage (i.e.,on disk) before the transaction is reported complete.
a transaction is set up by surrounding the SQL commands of the transaction with
BEGIN and COMMIT commands.
if in between donot want to complete transanction just issue command rollback
 A group of statements surrounded by BEGIN and COMMIT is sometimes
called a transaction block

Use "savepoint" and "rollback to" to control transaction inmore granural fashion.


#The PostgreSQL Joins clause is used to combine records from two or more tables in a database. A JOIN is a means for combining fields from two tables by using values common to each.

1.(INNER) JOIN: Returns records that have matching values in both tables

test=# select emp_id,name,dept from company inner join department on company.id=department.emp_id;
 emp_id | name  |    dept
--------+-------+-------------
      1 | Paul  | It Billing
      2 | Allen | Engineering
(2 rows)


2.LEFT (OUTER) JOIN: Returns all records from the left table, and the matched records from the right table
test=# select emp_id,name,dept from company left outer join department on company.id=department.emp_id;
 emp_id | name  |    dept
--------+-------+-------------
      1 | Paul  | It Billing
      2 | Allen | Engineering
        | David |
        | Mark  |
        | Teddy |
(5 rows)

3.RIGHT (OUTER) JOIN: Returns all records from the right table, and the matched records from the left table


test=# select emp_id,name,dept from company right outer join department on company.id=department.emp_id;
 emp_id | name  |    dept
--------+-------+-------------
      1 | Paul  | It Billing
      2 | Allen | Engineering
      7 |       | Finance
(3 rows)

#Inheritance - its is a concept in which the table inherits all column from its parent table . 
In PostgreSQL, a table can inherit from zero or more other tables.


test=# create table city(
test(# name text,
test(# population real,
test(# elevation int
test(# );
CREATE TABLE
test=# create table capitals(
test(# state char(2) unique not null
test(# ) inherits(city);
CREATE TABLE
test=# \d capitals
                  Table "public.capitals"
   Column   |     Type     | Collation | Nullable | Default
------------+--------------+-----------+----------+---------
 name       | text         |           |          |
 population | real         |           |          |
 elevation  | integer      |           |          |
 state      | character(2) |           | not null |
Indexes:
    "capitals_state_key" UNIQUE CONSTRAINT, btree (state)
Inherits: city


test=# insert into capitals values('chandigarh',1111,123,'PB');
INSERT 0 1
test=# insert into city values('ambala',123,221);
INSERT 0 1
test=# select * from capitals;
    name    | population | elevation | state
------------+------------+-----------+-------
 chandigarh |       1111 |       123 | PB
(1 row)


test=# select * from city;
    name    | population | elevation
------------+------------+-----------
 ambala     |        123 |       221
 chandigarh |       1111 |       123
(2 rows)


#SQL syntax
#Lexical Structure
sequence of tokens terminated by ;
Tokens can be hayward , identifier, constants or literal or special symbol
#Identifier
They identify name of tables columns or other db objects called names
starts with [9-2) followed by any alphabet, digit unserscore or $
They are case insensitive
convention  is to write key words in upper case and names in lower case
#then there is : the delimited identifier or quoted identifier
It is token in quotes whiuch is never treated as keyword
Then can contain ny character except 0
they are case sensitive

#Constants
There are three implicitly typed constants for use in Postgres: strings, integers, and floating point numbers. 
Strings in SQL are arbitrary sequences of ASCII characters bounded by single quotes ("'", e.g. 'This is a string'). 
Integer constants in SQL are collection of ASCII digits with no decimal point. Legal values range from -2147483648 to +2147483647.


---------------------------------------------------------------------------------------

Set Operations

UNION
The UNION operator is used to combine the result-set of two or more SELECT statements.

test=# select first_name from person union select name from teacher;
 first_name
------------
 Joe
 Hela
 David
 Chris
 Jessica
 John
(6 rows)

Union All- combine the results of two SELECT statements including duplicate rows

test=# select name from capitals union all select name from city;
    name
------------
 chandigarh
 ambala
 chandigarh
(3 rows)

---------------------------

 The purpose of JOIN was to merge two tables column wise rather the merging the rows like the union operator.
 In many scenarios we need to merge the content of multiple tables in order to get the necessary insight. 
The JOIN helps a database user to see the complex information in an easier table form which makes it easy to analyze.

      
test=# CREATE TABLE Employees (
test(#    employeeID INT PRIMARY KEY,
test(#    name VARCHAR (255) NOT NULL
test(# );
CREATE TABLE
test=# INSERT INTO Employees (
test(#    employeeID,
test(#    name
test(# ) VALUES (1, 'Asmar'), (2, 'Ali'), (3, 'Hassan'), (4, 'Anna'), (5, 'Sau'), (6, 'Kelsie'), (7, 'Tory'),
test-# (8, 'Salley');
INSERT 0 8

test-# CREATE TABLE Customer (
test(#    customerID INT PRIMARY KEY,
test(#    name VARCHAR (200)
test(# );
CREATE TABLE
test=# INSERT INTO Customer (
test(#    customerID,
test(#    name
test(# )
test-# VALUES (1, 'Ahmed'), (2, 'Moeez'), (3, 'Hussain'), (4, 'Abid'), (5, 'Sia'), (6, 'Kait'), (7, 'Tony'), (8, 'Sam');
INSERT 0 8
test=# CREATE TABLE Payment (
test(#    paymentID INT PRIMARY KEY,
test(#    customerID INT,
test(#    employeeID INT, amount INT,
test(#    FOREIGN KEY (employeeID)
test(#    REFERENCES Employees (employeeID)
test(#    ON DELETE CASCADE,
test(#    FOREIGN KEY (customerID)
test(#    REFERENCES Customer (customerID)
test(#    ON DELETE CASCADE
test(# );
CREATE TABLE
test=# INSERT INTO Payment (
test(#    paymentID, customerID, employeeID, amount
test(# )
test-# VALUES (1,2,1,2000), (2,1,2,3000), (3,4,3,3000), (4,5,4,4000), (5,3,5,4000), (6,6,6,5000),
test-#         (7,7,7,5000), (8,8,8,5000);
INSERT 0 8
test=# select * from payment;
 paymentid | customerid | employeeid | amount
-----------+------------+------------+--------
         1 |          2 |          1 |   2000
         2 |          1 |          2 |   3000
         3 |          4 |          3 |   3000
         4 |          5 |          4 |   4000
         5 |          3 |          5 |   4000
         6 |          6 |          6 |   5000
         7 |          7 |          7 |   5000
         8 |          8 |          8 |   5000
(8 rows)




#JOIN USING TWO TABLE
test=# select cust.name,pay.amount
test-# from Customer cust
test-# INNER JOIN Payment pay ON pay.customerID = cust.customerID;
  name   | amount
---------+--------
 Moeez   |   2000
 Ahmed   |   3000
 Abid    |   3000
 Sia     |   4000
 Hussain |   4000
 Kait    |   5000
 Tony    |   5000
 Sam     |   5000
(8 rows)
              
test=# select emp.name , pay.amount
test-# from employees emp
test-# inner join payment pay on pay.employeeID = emp.employeeID;
  name  | amount
--------+--------
 Asmar  |   2000
 Ali    |   3000
 Hassan |   3000
 Anna   |   4000
 Sau    |   4000
 Kelsie |   5000
 Tory   |   5000
 Salley |   5000
(8 rows)

#JOIN USING THREE TABLES

test=# select
test-# cust.name as cust_name,
test-# emp.name as emp_name,
test-# pay.amount
test-# from
test-# customer cust
test-# INNER JOIN Payment pay on pay.customerID = cust.customerID
test-# INNER JOIN Employees emp on pay.employeeID = emp.employeeID;
 cust_name | emp_name | amount
-----------+----------+--------
 Moeez     | Asmar    |   2000
 Ahmed     | Ali      |   3000
 Abid      | Hassan   |   3000
 Sia       | Anna     |   4000
 Hussain   | Sau      |   4000
 Kait      | Kelsie   |   5000
 Tony      | Tory     |   5000
 Sam       | Salley   |   5000
(8 rows)

-------------------------------------------

Fetch clause
Similair to limit used to get only portion of rows
Syntax:
OFFSET start { ROW | ROWS }
FETCH { FIRST | NEXT } [ row_count ] { ROW | ROWS } ONLY


test=# select * from Employees fetch next 2 row only;
 employeeid | name
------------+-------
          1 | Asmar
          2 | Ali
(2 rows)

show the second row

test=# select * from Employees offset 1 row fetch next 1 row only;
 employeeid | name
------------+------
          2 | Ali
(1 row)

#to show the connected database
test=# \c
You are now connected to database "test" as user "postgres".
 -------------------------------

#Indexes
Indexes are special lookup tables that the database search engine can use to speed up data retrieval. Simply put, an index is a pointer to data in a table. 
Speeds up select query with where clause but also slows down data input with insert and update query.
Create Indexes
test=# create index abc on company(name,age);
CREATE INDEX

Types of index:
Single-Column Indexes index created based on only one column in table.
test=# create index ab on company(name);
CREATE INDEX

Multicolumn Indexes  index created based on multiple column in table.
test=# create index abc on company(name,age);
CREATE INDEX

Unique index
used for data integrity as it does not allow any duplicated to be inserted into the table.
test=# create unique index uni on company(name);
CREATE INDEX


Partial index - index made over a subset of table it is defined by conditional expression and index contains rows whcih satisfy that condition.

Implicit Indexes
Implicit indexes are indexes that are automatically created by the database server when an object is created. Indexes are automatically created for primary key constraints and unique constraints.

test=# \d company
                       Table "public.company"
  Column   |         Type          | Collation | Nullable | Default
-----------+-----------------------+-----------+----------+---------
 id        | integer               |           | not null |
 name      | character varying(55) |           | not null |
 age       | integer               |           | not null |
 address   | character varying(55) |           |          |
 salary    | integer               |           |          |
 join_date | date                  |           |          |
Indexes:
    "company_pkey" PRIMARY KEY, btree (id)
    "ab" btree (name)
    "abc" btree (name, age)
    "uni" UNIQUE, btree (name)



 Drop index - deletes the index
test=# drop index abc;
DROP INDEX

#When should we avoid Indexes?
It should not be used on small tables.
Tables that have frequent, large batch update or insert operations.
It should not be used on columns that contain a high number of NULL values.
Columns that are frequently manipulated should not be indexed.

Functions/Stored Procedures
They allows to perform operations that would take several queries and loops into a single funtion in db
allows the reusability and other application can diretly run them without any middlelayer
Functions can be magein different languages like SQL, PL/pgSQL, C, Python, etc.
General syntax

CREATE [OR REPLACE] FUNCTION function_name (arguments) 
RETURNS return_datatype AS $variable_name$
   DECLARE
      declaration;
      [...]
   BEGIN
      < function_body >
      [...]
      RETURN { variable_name | value }
   END; LANGUAGE plpgsql;
   
here 

[OR REPLACE] option allows modifying an existing function.

The function must contain a return statement.

RETURN clause specifies that data type you are going to return from the function. The return_datatype can be a base, composite, or domain type, or can reference the type of a table column.

function-body contains the executable part.

The AS keyword is used for creating a standalone function.

plpgsql is the name of the language that the function is implemented in. Here, we use this option for PostgreSQL, it Can be SQL, C, internal, or the name of a user-defined procedural language. For backward compatibility, the name can be enclosed by single quotes.

So creating standalone function to find the max age in the company table
test1=# CREATE OR REPLACE FUNCTION maxage()
test1-# RETURNS integer AS $maxage$
test1$# declare
test1$# mage integer;
test1$# BEGIN
test1$#    SELECT max(age) into mage FROM COMPANY;
test1$#    RETURN mage;
test1$# END;
test1$# $maxage$ LANGUAGE plpgsql;
CREATE FUNCTION

Calling Function
Positional notation.
test1=# select maxage();
 maxage
--------
     32
(1 row)

Named notation

mix of both positonal argument can  not be after named argument


test1=# CREATE OR REPLACE FUNCTION totalRecords ()
test1-# RETURNS integer AS $total$
test1$# declare
test1$# total integer;
test1$# BEGIN
test1$#    SELECT count(*) into total FROM COMPANY;
test1$#    RETURN total;
test1$# END;
test1$# $total$ LANGUAGE plpgsql;
CREATE FUNCTION

test1=# select totalRecords();
 totalrecords
--------------
            7
(1 row)



Creating funtion to send the no of employees above certain age; 


create or replace function agecheck(agein int)
returns int as $allowed$
declare
ageno int;
begin
select count(*) into ageno from company where age>agein;
return ageno;
end;
$allowed$ language plpgsql;


Named notation

test1=# select agecheck(agein=> 28);
 agecheck
----------

PostgreSQL Triggers are database callback functions, which are automatically performed/invoked when a specified database event occurs.
postgreSQL trigger can be specified to fire
Before the operation is attempted on a row 
After the operation has completed
Instead of the operation

testdb=# CREATE TABLE info(
   ID INT PRIMARY KEY     NOT NULL,
   NAME           TEXT    NOT NULL,
   AGE            INT     NOT NULL,
   ADDRESS        CHAR(50),
   SALARY         REAL
);

testdb=# CREATE TABLE AUDIT(
   EMP_ID INT NOT NULL,
   ENTRY_DATE TEXT NOT NULL
);

test=# CREATE OR REPLACE FUNCTION auditlogfunc() RETURNS TRIGGER AS $example_table$
test$#    BEGIN
test$#       INSERT INTO AUDIT(EMP_ID, ENTRY_DATE) VALUES (new.ID, current_timestamp);
test$#       RETURN NEW;
test$#    END;
test$# $example_table$ LANGUAGE plpgsql;
CREATE FUNCTION



test=# create trigger ex_trigger after insert on info for each row execute procedure auditlogfunc();
CREATE TRIGGER
test=# insert into info
test-# values(1,'rahul',32,'cali',2000.0);
INSERT 0 1
test=# select * from audit;
 emp_id |            entry_date
--------+----------------------------------
      1 | 2022-04-07 01:05:05.679206+05:30
(1 row)

--------------------------------------------

The COALESCE function returns the first non-NULL expression in the specified list. If all the arguments are NULL then it will return NULL as its output. 

                                  ^
test=# select coalesce(join_date,'21-01-2011') from company;
  coalesce
------------
 2007-12-13
 2011-01-21
 2007-12-13
 2007-12-13
(4 rows)

---------------------------------------------------
Assert
provides the ASSERT statement for inserting important debugging checks in the PL/pgSQL code

Syntax: assert condition [, message]; 
condition: The condition is a boolean expression that is supposed to return true. 
If the condition returns true, the assert statement does nothing and the program continues to run.
However, if the condition is evaluated to false or null, then an ASSERT_FAILURE exception is raised. 
(If we encounter an error while evaluating the condition, it is reported as a normal error.)
 
message: The message is an optional part which is an expression whose result (if not null) replaces the default error message text  “assertion failed”, should the condition fail.

       
test=# create or replace function agecheckup(agein int)
test-# returns char(50) as $allowed$
test$# declare
test$#
test$# begin
test$# assert agein>20,'age low';
test$#
test$# end;
test$# $allowed$ language plpgsql;
CREATE FUNCTION
test=# select agecheckup(35);
ERROR:  control reached end of function without RETURN
CONTEXT:  PL/pgSQL function agecheckup(integer)
test=# select agecheckup(19);
ERROR:  age low
CONTEXT:  PL/pgSQL function agecheckup(integer) line 5 at ASSERT
test=#

-----------------------------------------------------

postgresql cast operator
it converts a value from one type to another
 syntax
 CAST ( expression AS target_type );
test=# select
test-# cast ('199' as integer);
 int4
------
  199
(1 row)

test=# select
test-# cast('07-APR-2022' as date);
    date
------------
 2022-04-07
(1 row)


test1=# SELECT
test1-#    CAST('true' AS BOOLEAN),
test1-#    CAST('false' as BOOLEAN),
test1-#    CAST('T' as BOOLEAN),
test1-#    CAST('F' as BOOLEAN);
 bool | bool | bool | bool
------+------+------+------
 t    | f    | t    | f
(1 row)

----------------------


Function over loading 
PostgreSQL allows more than one function to have the same name, as long as the arguments are different. When a function is called, PostgreSQL determines the exact function is being called based on the input arguments.


test=# create or replace function agecheck(agein int)
test-# returns int as $allowed$
test$# declare
test$# ageno int;
test$# begin
test$# select count(*) into ageno from company where age>agein;
test$# return ageno;
test$# end;
test$# $allowed$ language plpgsql;
CREATE FUNCTION
test=# create or replace function agecheck(agein int,ageout int)
test-# returns int as $allowed$
test$# declare
test$# ageno int;
test$# begin
test$# select count(*) into ageno from company where age between agein and ageout;
test$# return ageno;
test$# end;
test$# $allowed$ language plpgsql;
CREATE FUNCTION
test=# select count(*) from company where age between 25 and 30;
 count
-------
     3
(1 row)


test=# select agecheck(27);
 agecheck
----------
        0
(1 row)

AMS=# drop table if exists accounts;
NOTICE:  table "accounts" does not exist, skipping
DROP TABLE
AMS=# create table accounts (
AMS(# id int generated by default as identity,
AMS(# name varchar(100) not null,
AMS(# balance dec(15,2) not null,
AMS(# primary key(id)
AMS(# );
CREATE TABLE

AMS=# insert into accounts(name,balance)
values('Raju',10000),('Nikhil',10000);
INSERT 0 2
AMS=# create or replace procedure transfer(
AMS(# sender int,
AMS(# receiver int,
AMS(# amount dec
AMS(# )
AMS-# language plpgsql
AMS-# as $$
AMS$# begin
AMS$# update accounts=balance-amount
AMS$# where id=sender;
AMS$# update accounts
AMS$# set balance = balance+amount
AMS$# where id=receiver;
AMS$# commit;
AMS$# end;
AMS$# $$;
ERROR:  syntax error at or near "="
LINE 9: update accounts=balance-amount
                       ^
AMS=# create or replace procedure transfer(
sender int,
receiver int,
amount dec
)
language plpgsql
as $$
begin
update accounts set balance=balance-amount
CREATE PROCEDURE
AMS=# call transfer(1,2,1000);
CALL
AMS=# select * from accounts;
 id |  name  | balance  
----+--------+----------
  1 | Raju   |  9000.00
  2 | Nikhil | 11000.00
(2 rows)



AMS=# create table audit(
AMS(# emp_id int not null,
AMS(# entry_date text not null
AMS(# );
CREATE TABLE
AMS=# create trigger example_trigger after insert on Employee
AMS-# for each row execute procedure auditlogfunc();
ERROR:  function auditlogfunc() does not exist
AMS=# CREATE TRIGGER ex_trigger AFTER INSERT ON COMPANY
AMS-# FOR EACH ROW EXECUTE PROCEDURE auditlogfunc();
ERROR:  relation "company" does not exist
AMS=# CREATE TRIGGER ex_trigger AFTER INSERT ON Employee
FOR EACH ROW EXECUTE PROCEDURE auditlogfunc();
ERROR:  function auditlogfunc() does not exist
AMS=# create or replace function auditlog() returns trigger as $example_table$
AMS$# BEGIN
AMS$# insert into audit(emp_id,entry_date) values(new.ID,current_timestamp);
AMS$# RETURN NEW;
AMS$# END;
AMS$# $example_table$ LANGUAGE plpgsql;
CREATE FUNCTION
AMS=# CREATE TRIGGER example_trigger AFTER INSERT ON EMployee
AMS-# FOR EACH ROW EXECUTE PROCEDURE auditlog();
CREATE TRIGGER
AMS=# select * from EMployee;
AMS=# select * from Employee;
 employee_id |    name     | gender | age |   mobile   |      email       
-------------+-------------+--------+-----+------------+------------------
           1 | Joe Stark   | Male   |  33 | 1234567890 | joe@gmail.com
           2 | Virat Kohli | Male   |  35 | 1290876543 | virat@gmail.com
           3 | Sasha Calle | Female |  23 | 1209657387 | scalle@gmail.com
           4 | Clark Kent  | Male   |  33 | 1230000011 | ckent@yahoo.com
           5 | Lisa Ray    | Female |  55 |      11223 | lra@yahoo.com
(5 rows)


AMS=# create table company(
AMS(# id int primary key not null,
AMS(# name text not null,
AMS(# age int not null,
AMS(# address char(50),
AMS(# salary real
AMS(# );
CREATE TABLE
AMS=# create table audit(
AMS(# emp_id int not null,
AMS(# entry_date text not null
AMS(# );
ERROR:  relation "audit" already exists
AMS=# create or replace function auditlog() returns trigger as $example_table$
AMS$# begin
AMS$# insert into audit(emp_id,entry_date) values(new.ID,current_timestamp);
AMS$# RETURN NEW;
AMS$# END;
AMS$# $example_table$ LANGUAGE plpgsql;
CREATE FUNCTION
AMS=# CREATE TRIGGER example_trigger AFTER INSERT ON COMPANY
AMS-# FOR EACH ROW EXECUTE PROCEDURE auditlog();
CREATE TRIGGER
AMS=# insert into company(id,name,age,address,salary)
AMS-# values(1,'Raju',25,'New-Delhi,33000.00);
AMS'# ^C
AMS=# create or replace function auditlog() returns trigger as $example_table$
begin CREATE TRIGGER example_trigger AFTER INSERT ON COMPANY
FOR EA^C
AMS=# insert into company(id,name,age,address,salary)
AMS-# values(1,'Raju',25,'New-Delhi',33000.00);
INSERT 0 1
AMS=# select * from company;
 id | name | age |                      address                       | salary 
----+------+-----+----------------------------------------------------+--------
  1 | Raju |  25 | New-Delhi                                          |  33000
(1 row)

AMS=# 


book_collection_development=# select price,title from books group by price,title having price > 230;
 price |                 title                 
-------+---------------------------------------
   300 | The diary of young girl
   300 |           To Kill a Mockingbird      
   340 | Maths
   340 | Pride and Prejudice
   400 | Deep Work
   400 | The Power of habit
   420 | Harry Potter
   430 | 
   450 | Rich-Dad Poor-Dad
   499 | Rich Dad Poor Dad
   501 | Firestarter
   523 | IT
 10001 | The Shining
(13 rows)

hospital_management=# delete from appointment where id = 3;
DELETE 2
hospital_management=# select * from appointment;
 id |    date    | patient_id | doctor_id 
----+------------+------------+-----------
  1 | 2022-05-10 |          1 |         2
  2 | 2022-05-14 |          2 |         1
(2 rows)

                                        ^
hospital_management=# select name from patient where name like 'S%';
 name 
------
 Sam
(1 row)

hospital_management=# select name from patient where name like '%m';
 name 
------
 Sam
(1 row)


hospital_management=# select count(*) from patient group by name;
 count 
-------
     1
     1
     1
     1
(4 rows)

hospital_management=# select count(name) from patient group by name;
 count 
-------
     1
     1
     1
     1
(4 rows)

hospital_management=# select name from doctor order by name asc;
  name  
--------
 Amit
 Gunjan
 Steve
(3 rows)

hospital_management=# select count(*) from patient group by gender;
 count 
-------
     2
     2
(2 rows)

hospital_management=# select name from patient group by name;
  name   
---------
 Rohit
 Natasha
 Lisa
 Sam
(4 rows)

hospital_management=# select name,date from patient inner join appointment on patient.id = appointment.patient_id;
 name  |    date    
-------+------------
 Sam   | 2022-05-10
 Rohit | 2022-05-14
 Lisa  | 2022-06-01
(3 rows)

hospital_management=# select doctor.name as "Doctor Name",appointment.date,patient.name as "Patient Name" from appointment inner join patient on patient.id = appointment.patient_id
inner join doctor on doctor.id = appointment.doctor_id;
 Doctor Name |    date    | Patient Name 
-------------+------------+--------------
 Gunjan      | 2022-05-10 | Sam
 Amit        | 2022-05-14 | Rohit
 Steve       | 2022-06-01 | Lisa
(3 rows)




