What is a Database?
A database is information that is set up for easy access, management and updating.Databases are used for storing, maintaining and accessing any sort of data. They collect information on people, places or things. That information is gathered in one place so that it can be observed and analyzed. Databases can be thought of as an organized collection of information.

PostgreSql-
It is a powerful, open source object-relational database system.PostgreSQL runs on all major operating systems.PostgreSQL supports a large part of the SQL standard.
It is a highly stable database management system, backed by more than 20 years of community development which has contributed to its high levels of resilience, integrity, and correctness.
It uses the SQL language.

Commands in postgresql-
The DDL (Data Definition Language) commands are used to define the database. Example: CREATE, DROP, ALTER, TRUNCATE, COMMENT, RENAME.
The DML (Data Manipulation Language) commands deal with the manipulation of data present in the database. Example: SELECT, INSERT, UPDATE, DELETE.
The DCL (Data Control Language) commands deal with the permissions, rights and other controls of the database system. Example: GRANT, INVOKE.
The TCL (Transaction Control Language) commands deal with the transaction of the database.Example: BEGIN, COMMIT, ROLLBACK.


postgres=# select version();
                          version
------------------------------------------------------------
 PostgreSQL 14.2, compiled by Visual C++ build 1914, 64-bit
(1 row)

postgres-# \l
                                         List of databases
   Name    |  Owner   | Encoding |      Collate       |       Ctype        |   Access privileges
-----------+----------+----------+--------------------+--------------------+-----------------------
 postgres  | postgres | UTF8     | English_India.1252 | English_India.1252 |
 template0 | postgres | UTF8     | English_India.1252 | English_India.1252 | =c/postgres          +
           |          |          |                    |                    | postgres=CTc/postgres
 template1 | postgres | UTF8     | English_India.1252 | English_India.1252 | =c/postgres          +
           |          |          |                    |                    | postgres=CTc/postgres
(3 rows)


postgres=# create database test;
CREATE DATABASE

test-#
Here # shows I am Super User
test=>
" => " have rights to the database

postgres-# \?
General
  \copyright             show PostgreSQL usage and distribution terms
  \crosstabview [COLUMNS] execute query and display results in crosstab
  \errverbose            show most recent error message at maximum verbosity
  \g [(OPTIONS)] [FILE]  execute query (and send results to file or |pipe);
                         \g with no arguments is equivalent to a semicolon
  \gdesc                 describe result of query, without executing it
  \gexec                 execute query, then execute each value in its result
  \gset [PREFIX]         execute query and store results in psql variables
  \gx [(OPTIONS)] [FILE] as \g, but forces expanded output mode
  \q                     quit psql
  \watch [SEC]           execute query every SEC seconds

Help
  \? [commands]          show help on backslash commands
  \? options             show help on psql command-line options
  \? variables           show help on special variables
  \h [NAME]              help on syntax of SQL commands, * for all commands

Query Buffer
  \e [FILE] [LINE]       edit the query buffer (or file) with external editor
  \ef [FUNCNAME [LINE]]  edit function definition with external editor
  \ev [VIEWNAME [LINE]]  edit view definition with external editor
  \p                     show the contents of the query buffer
  \r                     reset (clear) the query buffer
  \w FILE                write query buffer to file

Input/Output
  \copy ...              perform SQL COPY with data stream to the client host
-- More  --


#To see current date
# select current_date;
 current_date
--------------
 2022-04-01


#running an arithmetic operation
postgres=# select 2+2;
 ?column?
----------
        4
(1 row)

#to permanently delete a database;
 drop database test1;
DROP DATABASE

#to change database
test=# \c test1;
You are now connected to database "test1" as user "postgres".


Table synatx - 

CREATE TABLE table_name(
Column name + data type + constraints if any
)

test=# create table person (
test(# id int not null primary key,
test(# first_name varchar(50) not null,
test(# last_name varchar(50) not null,
test(# gender varchar(7) not null,
test(# date_of_birth date not null,
test(# email varchar(150)  );
CREATE TABLE


#to view table
test=# \d
         List of relations
 Schema |  Name  | Type  |  Owner
--------+--------+-------+----------
 public | person | table | postgres
(1 row)



test=# \d person;
                          Table "public.person"
    Column     |          Type          | Collation | Nullable | Default
---------------+------------------------+-----------+----------+---------
 id            | integer                |           | not null |
 first_name    | character varying(50)  |           | not null |
 last_name     | character varying(50)  |           | not null |
 gender        | character varying(7)   |           | not null |
 date_of_birth | date                   |           | not null |
 email         | character varying(150) |           |          |
Indexes:
    "person_pkey" PRIMARY KEY, btree (id)


#to delete a table
test=# drop table person;
DROP TABLE


test=# \dt
         List of relations
 Schema |  Name  | Type  |  Owner
--------+--------+-------+----------
 public | person | table | postgres
(1 row)


#inserting values into table

test=# insert into person (id, first_name, last_name, gender, date_of_birth)
test-# values(1,'John','Smith','Male',date '2000-11-04');
INSERT 0 1
test=# insert into person (id, first_name,last_name, gender, date_of_birth, email)
test-# values(2,'Jessica','Jones','Female',date '1999-05-05','jessica@gmail.com');
INSERT 0 1
test=# insert into person (id,first_name,last_name,gender,date_of_birth,email)
test-# values(3,'David','Ayers','Male',date '1999=06-07','david@gmail.com');
INSERT 0 1
test=# insert into person (id,first_name,last_name,gender,date_of_birth,email)
test-# values(4,'Chris','Evans','Male',date '1998-07-11','chris@gmail.com');
INSERT 0 1
test=# insert into person (id,first_name,last_name,gender,date_of_birth,email)
test-# values(5,'Hela','Ray','Female',date '1996-09-12','hela@gmail.com');
INSERT 0 1


 SELECT statement is used to fetch the data from a database table,
test=# select * from person;
 id | first_name | last_name | gender | date_of_birth |       email
----+------------+-----------+--------+---------------+-------------------
  1 | John       | Smith     | Male   | 2000-11-04    | john@gmail.com
  2 | Jessica    | Jones     | Female | 1999-05-05    | jessica@gmail.com
  3 | David      | Ayers     | Male   | 1999-06-07    | david@gmail.com
  4 | Chris      | Evans     | Male   | 1998-07-11    | chris@gmail.com
  5 | Hela       | Ray       | Female | 1996-09-12    | hela@gmail.com
(5 rows)


test=# select first_name, last_name from person;
 first_name | last_name
------------+-----------
 John       | Smith
 Jessica    | Jones
 David      | Ayers
 Chris      | Evans
 Hela       | Ray
(5 rows)


test=# select * from person order by first_name;
 id | first_name | last_name | gender | date_of_birth |       email
----+------------+-----------+--------+---------------+-------------------
  4 | Chris      | Evans     | Male   | 1998-07-11    | chris@gmail.com
  3 | David      | Ayers     | Male   | 1999-06-07    | david@gmail.com
  5 | Hela       | Ray       | Female | 1996-09-12    | hela@gmail.com
  2 | Jessica    | Jones     | Female | 1999-05-05    | jessica@gmail.com
  1 | John       | Smith     | Male   | 2000-11-04    | john@gmail.com
(5 rows)



test=# select * from person order by id DESC;
 id | first_name | last_name | gender | date_of_birth |       email
----+------------+-----------+--------+---------------+-------------------
  5 | Hela       | Ray       | Female | 1996-09-12    | hela@gmail.com
  4 | Chris      | Evans     | Male   | 1998-07-11    | chris@gmail.com
  3 | David      | Ayers     | Male   | 1999-06-07    | david@gmail.com
  2 | Jessica    | Jones     | Female | 1999-05-05    | jessica@gmail.com
  1 | John       | Smith     | Male   | 2000-11-04    | john@gmail.com
(5 rows)



test=# select * from person where gender='Female';
 id | first_name | last_name | gender | date_of_birth |       email
----+------------+-----------+--------+---------------+-------------------
  2 | Jessica    | Jones     | Female | 1999-05-05    | jessica@gmail.com
  5 | Hela       | Ray       | Female | 1996-09-12    | hela@gmail.com



test=# SELECT 1<2;
 ?column?
----------
 t
(1 row)

 Select * from person where last_name in ('Jones','Evans','Ray');
 id | first_name | last_name | gender | date_of_birth |       email
----+------------+-----------+--------+---------------+-------------------
  2 | Jessica    | Jones     | Female | 1999-05-05    | jessica@gmail.com
  4 | Chris      | Evans     | Male   | 1998-07-11    | chris@gmail.com
  5 | Hela       | Ray       | Female | 1996-09-12    | hela@gmail.com
(3 rows)




WHERE CLAUSE - used to specify a condition while fetching the data from single table or joining with multiple tables.

syntax:SELECT column1, column2, columnN
                             FROM table_name
                             WHERE [search_condition]
test=# select * from person where first_name like 'J%';
 id | first_name | last_name | gender | date_of_birth |       email
----+------------+-----------+--------+---------------+-------------------
  1 | John       | Smith     | Male   | 2000-11-04    | john@gmail.com
  2 | Jessica    | Jones     | Female | 1999-05-05    | jessica@gmail.com
(2 rows)



test=# create table company (
test(# id int not null primary key,
test(# name varchar(55) not null,
test(# age int not null,
test(# address varchar(55) not null,
test(# salary int not null,
test(# join_date date not null );
CREATE TABLE
test=# \d
          List of relations
 Schema |  Name   | Type  |  Owner
--------+---------+-------+----------
 public | company | table | postgres
 public | person  | table | postgres
 public | teacher | table | postgres
(3 rows)


test=# insert into company (id,name,age,address,salary,join_date)
test-# values(1,'Paul',23,'Texas',10000,'2001-07-13'),
test-# (2,'Rahul',34,'California',85000,'2007-08-11'),
test-# (3,'Nitin',33,'Rich-Mond',45000,'2010-12-13'),
test-# (4,'Joe',45,'Texas',90000,'2000-11-05');
INSERT 0 4
test=# select * from company;
 id | name  | age |  address   | salary | join_date
----+-------+-----+------------+--------+------------
  1 | Paul  |  23 | Texas      |  10000 | 2001-07-13
  2 | Rahul |  34 | California |  85000 | 2007-08-11
  3 | Nitin |  33 | Rich-Mond  |  45000 | 2010-12-13
  4 | Joe   |  45 | Texas      |  90000 | 2000-11-05
(4 rows)

select * from company where age>=25 or salary>=65000;
 id | name  | age |  address   | salary | join_date
----+-------+-----+------------+--------+------------
  2 | Rahul |  34 | California |  85000 | 2007-08-11
  3 | Nitin |  33 | Rich-Mond  |  45000 | 2010-12-13
  4 | Joe   |  45 | Texas      |  90000 | 2000-11-05
(3 rows)




#Update query with where clause;
                 
                  syntax:UPDATE table_name
                  SET column1 = value1, column2 = value2...., columnN = valueN
                  WHERE [condition];

update company set join_date = '2002-07-03' where id=3;
UPDATE 1
test=# select * from company;
 id | name  | age |  address   | salary | join_date
----+-------+-----+------------+--------+------------
  1 | Paul  |  23 | Texas      |  10000 | 2001-07-13
  2 | Rahul |  34 | California |  85000 | 2007-08-11
  4 | Joe   |  45 | Texas      |  90000 | 2000-11-05
  3 | Nitin |  33 | Rich-Mond  |  45000 | 2002-07-03
(4 rows)


 #Delete query 

          syntax: DELETE FROM table_name  WHERE condition;
           delete from company where id=2;

 id | name  | age |  address  | salary | join_date
----+-------+-----+-----------+--------+------------
  1 | Paul  |  23 | Texas     |  10000 | 2001-07-13
  4 | Joe   |  45 | Texas     |  90000 | 2000-11-05
  3 | Nitin |  33 | Rich-Mond |  45000 | 2002-07-03


#ORDER by:ORDER BY clause is used to sort the data in ascending or descending order.
              
                   syntax:SELECT column-list
                          FROM table_name
                          [WHERE condition]
                          [ORDER BY column1, column2, .. columnN] [ASC | DESC];

                    test=# select * from company order by name, salary asc;
 id | name  | age |  address  | salary | join_date
----+-------+-----+-----------+--------+------------
  4 | Joe   |  45 | Texas     |  90000 | 2000-11-05
  3 | Nitin |  33 | Rich-Mond |  45000 | 2002-07-03
  1 | Paul  |  23 | Texas     |  10000 | 2001-07-13


29.GROUP BY: GROUP BY clause is used in collaboration with the SELECT statement to group together those rows in a table that have identical data.

                                        syntax:SELECT column-list
                                               FROM table_name
                                               WHERE [ conditions ]
                                               GROUP BY column1, column2....columnN
                                               ORDER BY column1, column2....columnN
                                         test=# select address, count(*) from company group by address;
  address  | count
-----------+-------
 Rich-Mond |     1
 Texas     |     2
(2 rows)


#Views in SQL are kind of virtual tables. A view also has rows and columns as they are in a real table in the database.

The basic CREATE VIEW syntax is as follows −

CREATE [TEMP | TEMPORARY] VIEW view_name AS
SELECT column1, column2.....
FROM table_name
WHERE [condition];



test=# create VIEW myview as
test-# select name,age,address,salary
test-# from company;
CREATE VIEW

       ^
test=#  select * from myview;
 name  | age |  address  | salary
-------+-----+-----------+--------
 Paul  |  23 | Texas     |  10000
 Joe   |  45 | Texas     |  90000
 Nitin |  33 | Rich-Mond |  45000
(3 rows)


#to drop a view-
test=# drop view myview;
DROP VIEW

#primary key-A primary key is a column or a group of columns used to identify a row uniquely in a table.

test=# insert into person(id,first_name,last_name,gender,date_of_birth,email) values (1,'John','Smith','Male','2000-11-04','john@gmail.com');
ERROR:  duplicate key value violates unique constraint "person_pkey"
DETAIL:  Key (id)=(1) already exists.

to remove the primary key
test=# ALTER TABLE person DROP CONSTRAINT person_pkey;
ALTER TABLE

to add the primary key
 ALTER TABLE person ADD PRIMARY KEY (id);
ALTER TABLE

#Unique Constraints - A UNIQUE CONSTRAINT is used to maintain the individuality of the values that we store into a field or a column of the table. 
It is compatible with a group of column constraints or column constraints and a table constraint.

test=# ALTER TABLE person ADD CONSTRAINT unique_email_address UNIQUE (email);
ALTER TABLE

test=# \d person;
                          Table "public.person"
    Column     |          Type          | Collation | Nullable | Default
---------------+------------------------+-----------+----------+---------
 id            | integer                |           | not null |
 first_name    | character varying(50)  |           | not null |
 last_name     | character varying(50)  |           | not null |
 gender        | character varying(7)   |           | not null |
 date_of_birth | date                   |           | not null |
 email         | character varying(150) |           |          |
Indexes:
    "person_pkey" PRIMARY KEY, btree (id)
    "unique_email_address" UNIQUE CONSTRAINT, btree (email)


#A foreign key constraint specifies that the values in a column (or a group of columns) must match the values appearing in some row of another table. 
It maintains the referential integrity between two related tables. 
They are called foreign keys because the constraints are foreign; that is, outside the table.
                   ^
test=# create table company1(
test(# id int primary key not null,
test(# name varchar(50) not null,
test(# age int not null,
test(# address varchar(50),
test(# salary int
test(# );
CREATE TABLE


test=# create table department1(
test(# id int primary key not null,
test(# dept varchar(50) not null,
test(# emp_id int references company1(id)
test(# );
CREATE TABLE
test=# select * from department1;
 id | dept | emp_id
----+------+--------
(0 rows)


test=# \d department1;
                   Table "public.department1"
 Column |         Type          | Collation | Nullable | Default
--------+-----------------------+-----------+----------+---------
 id     | integer               |           | not null |
 dept   | character varying(50) |           | not null |
 emp_id | integer               |           |          |
Indexes:
    "department1_pkey" PRIMARY KEY, btree (id)
Foreign-key constraints:
    "department1_emp_id_fkey" FOREIGN KEY (emp_id) REFERENCES company1(id)



# Transactions
It is fundamental concept of Database systems.
It bundles multiple steps into one for all or nothing operation.
it help to provide atomicity propertty of datatbase ie if some failure occurs that prevents the transaction from completing, then none of the steps affect the database at all
A transactional database guarantees that all the updates made by a transaction are logged in permanent storage (i.e.,on disk) before the transaction is reported complete.
a transaction is set up by surrounding the SQL commands of the transaction with
BEGIN and COMMIT commands.
if in between donot want to complete transanction just issue command rollback
 A group of statements surrounded by BEGIN and COMMIT is sometimes
called a transaction block

Use "savepoint" and "rollback to" to control transaction inmore granural fashion.


#The PostgreSQL Joins clause is used to combine records from two or more tables in a database. A JOIN is a means for combining fields from two tables by using values common to each.

1.(INNER) JOIN: Returns records that have matching values in both tables

test=# select emp_id,name,dept from company inner join department on company.id=department.emp_id;
 emp_id | name  |    dept
--------+-------+-------------
      1 | Paul  | It Billing
      2 | Allen | Engineering
(2 rows)


2.LEFT (OUTER) JOIN: Returns all records from the left table, and the matched records from the right table
test=# select emp_id,name,dept from company left outer join department on company.id=department.emp_id;
 emp_id | name  |    dept
--------+-------+-------------
      1 | Paul  | It Billing
      2 | Allen | Engineering
        | David |
        | Mark  |
        | Teddy |
(5 rows)

3.RIGHT (OUTER) JOIN: Returns all records from the right table, and the matched records from the left table


test=# select emp_id,name,dept from company right outer join department on company.id=department.emp_id;
 emp_id | name  |    dept
--------+-------+-------------
      1 | Paul  | It Billing
      2 | Allen | Engineering
      7 |       | Finance
(3 rows)

#Inheritance - its is a concept in which the table inherits all column from its parent table . 
In PostgreSQL, a table can inherit from zero or more other tables.


test=# create table city(
test(# name text,
test(# population real,
test(# elevation int
test(# );
CREATE TABLE
test=# create table capitals(
test(# state char(2) unique not null
test(# ) inherits(city);
CREATE TABLE
test=# \d capitals
                  Table "public.capitals"
   Column   |     Type     | Collation | Nullable | Default
------------+--------------+-----------+----------+---------
 name       | text         |           |          |
 population | real         |           |          |
 elevation  | integer      |           |          |
 state      | character(2) |           | not null |
Indexes:
    "capitals_state_key" UNIQUE CONSTRAINT, btree (state)
Inherits: city


test=# insert into capitals values('chandigarh',1111,123,'PB');
INSERT 0 1
test=# insert into city values('ambala',123,221);
INSERT 0 1
test=# select * from capitals;
    name    | population | elevation | state
------------+------------+-----------+-------
 chandigarh |       1111 |       123 | PB
(1 row)


test=# select * from city;
    name    | population | elevation
------------+------------+-----------
 ambala     |        123 |       221
 chandigarh |       1111 |       123
(2 rows)


#SQL syntax
#Lexical Structure
sequence of tokens terminated by ;
Tokens can be hayward , identifier, constants or literal or special symbol
#Identifier
They identify name of tables columns or other db objects called names
starts with [9-2) followed by any alphabet, digit unserscore or $
They are case insensitive
convention  is to write key words in upper case and names in lower case
#then there is : the delimited identifier or quoted identifier
It is token in quotes whiuch is never treated as keyword
Then can contain ny character except 0
they are case sensitive

#Constants
There are three implicitly typed constants for use in Postgres: strings, integers, and floating point numbers. 
Strings in SQL are arbitrary sequences of ASCII characters bounded by single quotes ("'", e.g. 'This is a string'). 
Integer constants in SQL are collection of ASCII digits with no decimal point. Legal values range from -2147483648 to +2147483647.


---------------------------------------------------------------------------------------

Set Operations

UNION
The UNION operator is used to combine the result-set of two or more SELECT statements.

test=# select first_name from person union select name from teacher;
 first_name
------------
 Joe
 Hela
 David
 Chris
 Jessica
 John
(6 rows)

Union All- combine the results of two SELECT statements including duplicate rows

test=# select name from capitals union all select name from city;
    name
------------
 chandigarh
 ambala
 chandigarh
(3 rows)

---------------------------

 The purpose of JOIN was to merge two tables column wise rather the merging the rows like the union operator.
 In many scenarios we need to merge the content of multiple tables in order to get the necessary insight. 
The JOIN helps a database user to see the complex information in an easier table form which makes it easy to analyze.

      
test=# CREATE TABLE Employees (
test(#    employeeID INT PRIMARY KEY,
test(#    name VARCHAR (255) NOT NULL
test(# );
CREATE TABLE
test=# INSERT INTO Employees (
test(#    employeeID,
test(#    name
test(# ) VALUES (1, 'Asmar'), (2, 'Ali'), (3, 'Hassan'), (4, 'Anna'), (5, 'Sau'), (6, 'Kelsie'), (7, 'Tory'),
test-# (8, 'Salley');
INSERT 0 8

test-# CREATE TABLE Customer (
test(#    customerID INT PRIMARY KEY,
test(#    name VARCHAR (200)
test(# );
CREATE TABLE
test=# INSERT INTO Customer (
test(#    customerID,
test(#    name
test(# )
test-# VALUES (1, 'Ahmed'), (2, 'Moeez'), (3, 'Hussain'), (4, 'Abid'), (5, 'Sia'), (6, 'Kait'), (7, 'Tony'), (8, 'Sam');
INSERT 0 8
test=# CREATE TABLE Payment (
test(#    paymentID INT PRIMARY KEY,
test(#    customerID INT,
test(#    employeeID INT, amount INT,
test(#    FOREIGN KEY (employeeID)
test(#    REFERENCES Employees (employeeID)
test(#    ON DELETE CASCADE,
test(#    FOREIGN KEY (customerID)
test(#    REFERENCES Customer (customerID)
test(#    ON DELETE CASCADE
test(# );
CREATE TABLE
test=# INSERT INTO Payment (
test(#    paymentID, customerID, employeeID, amount
test(# )
test-# VALUES (1,2,1,2000), (2,1,2,3000), (3,4,3,3000), (4,5,4,4000), (5,3,5,4000), (6,6,6,5000),
test-#         (7,7,7,5000), (8,8,8,5000);
INSERT 0 8
test=# select * from payment;
 paymentid | customerid | employeeid | amount
-----------+------------+------------+--------
         1 |          2 |          1 |   2000
         2 |          1 |          2 |   3000
         3 |          4 |          3 |   3000
         4 |          5 |          4 |   4000
         5 |          3 |          5 |   4000
         6 |          6 |          6 |   5000
         7 |          7 |          7 |   5000
         8 |          8 |          8 |   5000
(8 rows)




#JOIN USING TWO TABLE
test=# select cust.name,pay.amount
test-# from Customer cust
test-# INNER JOIN Payment pay ON pay.customerID = cust.customerID;
  name   | amount
---------+--------
 Moeez   |   2000
 Ahmed   |   3000
 Abid    |   3000
 Sia     |   4000
 Hussain |   4000
 Kait    |   5000
 Tony    |   5000
 Sam     |   5000
(8 rows)
              
test=# select emp.name , pay.amount
test-# from employees emp
test-# inner join payment pay on pay.employeeID = emp.employeeID;
  name  | amount
--------+--------
 Asmar  |   2000
 Ali    |   3000
 Hassan |   3000
 Anna   |   4000
 Sau    |   4000
 Kelsie |   5000
 Tory   |   5000
 Salley |   5000
(8 rows)

#JOIN USING THREE TABLES

test=# select
test-# cust.name as cust_name,
test-# emp.name as emp_name,
test-# pay.amount
test-# from
test-# customer cust
test-# INNER JOIN Payment pay on pay.customerID = cust.customerID
test-# INNER JOIN Employees emp on pay.employeeID = emp.employeeID;
 cust_name | emp_name | amount
-----------+----------+--------
 Moeez     | Asmar    |   2000
 Ahmed     | Ali      |   3000
 Abid      | Hassan   |   3000
 Sia       | Anna     |   4000
 Hussain   | Sau      |   4000
 Kait      | Kelsie   |   5000
 Tony      | Tory     |   5000
 Sam       | Salley   |   5000
(8 rows)
