Arrays are ordered,integer-indexed collections of any object.

Array indexing starts at 0, as in C or Java. A negative index is assumed to be relative to the end of the array—that is, an index of -1 indicates the last element of the array, -2 is the next to last element in the array

A new array can be created by using the literal constructor []
It can contain different type of objects.
3.0.0 :001 > ary = [1, "two", 3.0]
 => [1, "two", 3.0] 
 

#we can create array also by using Array.new
with zero,one(initial size of array),or 2 arguments(initial size nd object)
3.0.0 :002 > ary = Array.new
 => [] 
3.0.0 :003 > Array.new(3)
 => [nil, nil, nil] 
3.0.0 :004 > Array.new(3, true)
 => [true, true, true] 
 
#we can also creare array using [] 
3.0.0 :001 > arr = Array['a','b','c','d','e','f']
 => ["a", "b", "c", "d", "e", "f"] 
3.0.0 :002 > puts "#{arr}"
["a", "b", "c", "d", "e", "f"]
 => nil 
3.0.0 :003 > puts "Size of arr is: #{arr.size}"
Size of arr is: 6
 => nil 
3.0.0 :004 > puts "Length of arr is: #{arr.length}"
Length of arr is: 6
 => nil 

to create an array with separate objects a block can be passed instead
3.0.0 :001 > Array.new(4) {|i| i.to_s}
 => ["0", "1", "2", "3"] 
3.0.0 :002 > Array.new(6) {|i| i.to_s}
 => ["0", "1", "2", "3", "4", "5"] 

=> to use multi-dimensional arrays
3.0.0 :003 > empty = Array.new(3) {Array.new(3)}
 => [[nil, nil, nil], [nil, nil, nil], [nil, nil, nil]] 
 
 #Retrieving Multiple Elements from array
 3.0.0 :005 > str = ["Virat","Dhoni","Yuvraj"]
 => ["Virat", "Dhoni", "Yuvraj"]
 3.0.0 :008 > puts str[1,2]
Dhoni
Yuvraj
 => nil 

#Obtaining Information about an array

3.0.0 :009 > browsers = ['Chrome','Firefox','Safari','Opera','IE']
 => ["Chrome", "Firefox", "Safari", "Opera", "IE"] 
3.0.0 :010 > browsers.length
 => 5 
3.0.0 :011 > browsers.count
 => 5 
3.0.0 :012 > browsers.empty?
 => false 
3.0.0 :013 > browsers.include?('Konqueror')
 => false 

#add item to array
3.0.0 :002 > arr = [1,2,3,4,5]
 => [1, 2, 3, 4, 5] 
3.0.0 :003 > arr.push(5)
 => [1, 2, 3, 4, 5, 5] 
3.0.0 :004 > arr << 6
 => [1, 2, 3, 4, 5, 5, 6]

to add a item to beginning of an array 
3.0.0 :005 > arr.unshift(0)
 => [0, 1, 2, 3, 4, 5, 5, 6] 
 
3.0.0 :006 > arr.insert(3, 'apple')
 => [0, 1, 2, "apple", 3, 4, 5, 5, 6] 
3.0.0 :007 > arr.insert(3, 'orange','pear','grapefruit')
 => [0, 1, 2, "orange", "pear", "grapefruit", "apple", 3, 4, 5, 5, 6] 


 #remove item from array
 
 this delete last item 
 3.0.0 :009 > arr.pop
 => 6 
3.0.0 :010 > arr
 => [0, 1, 2, "orange", "pear", "grapefruit", "apple", 3, 4, 5, 5] 
3.0.0 :011 > arr.shift
 => 0 
3.0.0 :012 > arr
 => [1, 2, "orange", "pear", "grapefruit", "apple", 3, 4, 5, 5] 

to delete at particular index
3.0.0 :013 > arr.delete_at(2)
 => "orange" 
3.0.0 :014 > arr.delete(4)
 => 4 

to remove nil values from array
 3.0.0 :015 > arr = ['foo', 0, nil,'bar',7,'bar',nil]
 => ["foo", 0, nil, "bar", 7, "bar", nil] 
3.0.0 :016 > arr.compact
 => ["foo", 0, "bar", 7, "bar"] 
3.0.0 :017 > arr
 => ["foo", 0, nil, "bar", 7, "bar", nil] 
3.0.0 :018 > arr.compact!
 => ["foo", 0, "bar", 7, "bar"] 
3.0.0 :019 > arr
 => ["foo", 0, "bar", 7, "bar"] 

to remove duplicate elemennts
3.0.0 :020 > arr = [2,5,6,6,5,4,4,2,2,1,1,99,99,88]
 => [2, 5, 6, 6, 5, 4, 4, 2, 2, 1, 1, 99, 99, 88] 
3.0.0 :021 > arr.uniq
 => [2, 5, 6, 4, 1, 99, 88] 

#to iterate over array
(this operation leaves the array unchanged)
3.0.0 :023 > arr.each {|a| print a -= 10, " "}
-9 -8 -7 -6 -5  => [1, 2, 3, 4, 5]

reverse the elements in array
 3.0.0 :032]> Words = %w[hi there how are you]
 => ["hi", "there", "how", "are", "you"] 
3.0.0 :033"> str = ""
 => "" 
3.0.0 :034 > Words.reverse_each {|word| str += "#{word} "}
 => ["hi", "there", "how", "are", "you"] 
3.0.0 :035 > p str
"you are how there hi "
 => "you are how there hi " 
3.0.0 :036 > 

=>the map method is used to create a new array based on original array
3.0.0 :036 > arr.map {|a| 2*a}
 => [2, 4, 6, 8, 10] 
3.0.0 :037 > arr
 => [1, 2, 3, 4, 5] 
3.0.0 :038 > arr.map! {|a| 2*a}
 => [2, 4, 6, 8, 10] 
3.0.0 :039 > arr
 => [2, 4, 6, 8, 10] 

#non-destructive selection
3.0.0 :041 > arr.select {|a| a > 3}
 => [4, 5, 6] 
3.0.0 :042 > arr.reject{|a| a < 3}
 => [3, 4, 5, 6] 
3.0.0 :043 > arr.drop_while {|a| a < 4}
 => [4, 5, 6] 

#destructive selection
.0.0 :044 > arr.delete_if {|a| a < 4}
 => [4, 5, 6] 
3.0.0 :045 > arr
 => [4, 5, 6] 
3.0.0 :046 > arr = [1,2,3,4,5,6]
 => [1, 2, 3, 4, 5, 6] 
3.0.0 :047 > arr.keep_if {|a| a < 4}
 => [1, 2, 3] 

#Public Class Methods
 [](*args)
Returns a new array populated with the given objects.
.0 :048 > Array.[](1, 'a', /^A/)
 => [1, "a", /^A/] 

When a size and an optional default are sent, an array is created with size copies of default

0 :049 > first_array = ["Rohit","Sam"]
 => ["Rohit", "Sam"] 
3.0.0 :050 > second_array = Array.new(first_array)
 => ["Rohit", "Sam"] 
3.0.0 :051 > first_array.equal? second_array
 => false 

0 :052 > Array.new(3) {|index| index ** 2}
 => [0, 1, 4] 
 
 #Since all the array elements store the same hash,changes to one of them will affect them all.
 3.0.0 :055 > a = Array.new(2,Hash.new)
 => [{}, {}] 
3.0.0 :056 > a[0]['cat'] = 'feline'
 => "feline" 
3.0.0 :057'> a[1]['cat'] = 'felix'
 => "felix" 
3.0.0 :058 > a
 => [{"cat"=>"felix"}, {"cat"=>"felix"}] 

if multiple copies are what you want, you should use the block version which uses the result of that block each time an element of the array needs to be initialized:
3.0.0 :059 > a = Array.new(2) {Hash.new}
 => [{}, {}] 
3.0.0 :060'> a[0]['cat'] = 'feline'
 => "feline" 
3.0.0 :061 > a
 => [{"cat"=>"feline"}, {}] 

#to convert array into object
3.0.0 :069 > Array.try_convert([1])
 => [1] 
3.0.0 :070 > Array.try_convert("1")
 => nil 


#Public Instance Methods

Set Intersection — Returns a new array containing unique elements common to the two arrays. The order is preserved from the original array.
3.0.0 :071 > [1,1,3,5] & [3,2,1]
 => [1, 3]
3.0.0 :072 > ['a','b','b','z'] & ['a','b','c']
 => ["a", "b"] 
 
Repetition — With a String argument, equivalent to ary.join(str).
Otherwise, returns a new array built by concatenating the int copies of self.

3.0.0 :073 > [ 1,2,3 ] * 3
 => [1, 2, 3, 1, 2, 3, 1, 2, 3] 
3.0.0 :074"> [1,2,3] * ""
 => "123" 
3.0.0 :075 

Concatenation — Returns a new array built by concatenating the two arrays together to produce a third array.
3.0.0 :076 > a = ["hi","hello"]
 => ["hi", "hello"] 
3.0.0 :077 > c = a + ["wassup"]
 => ["hi", "hello", "wassup"] 

#Array Difference
Returns a new array that is a copy of the original array, removing all occurrences of any item that also appear in other_ary
 all occurrences of each Integer are removed in the returned array.
 
 3.0.0 :078 > [1,1,2,3,4,5,3] - [1,3,2]
 => [4, 5] 

Append—Pushes the given object on to the end of this array. This expression returns the array itself, so several appends may be chained together.
3.0.0 :080 > a << "c" << [3,4]
 => [1, 2, "c", [3, 4]] 
 
 Comparison — Returns an integer (-1, 0, or +1) if this array is less than, equal to, or greater than other_ary.
 3.0.0 :001 > ["a", "a", "c" ] <=> ["a","b","c"]
 => -1 
3.0.0 :002 > [1,2,3,4,5,6] <=> [ 1, 2]
 => 1 
3.0.0 :003 > [1,2] <=> [1, :two]
 => nil 

Equality — Two arrays are equal if they contain the same number of elements and if each element is equal to the corresponding element in other_ary.
3.0.0 :004 > ["a", "c"] == ["a","c",7]
 => false 
3.0.0 :005 > ["a", "c"] == ["a","c"]
 => true 

3.0.0 :009 > a[1, 3]
 => ["b", "c", "d"] 
3.0.0 :010 > a[1..3]
 => ["b", "c", "d"] 
3.0.0 :011 > a[1...4]
 => ["b", "c", "d"] 
3.0.0 :012 > a[-3,3]
 => ["c", "d", "e"] 
3.0.0 :013 > a[5]
 => nil 
3.0.0 :014 > a[6 , 1]
 => nil 

#assoc 
Searches through an array whose elements are also arrays comparing obj with the first element of each contained array using obj.==.
3.0.0 :015 > s1 = ["colors","red","blue","green"]
 => ["colors", "red", "blue", "green"] 
3.0.0 :016 > s2 = ["letters","a","b","c"]
 => ["letters", "a", "b", "c"] 
3.0.0 :017 > s3 = "foo"
 => "foo" 
3.0.0 :018 > a.assoc("letters")
 => nil 
3.0.0 :019 > a = [s1,s2,s3]
 => [["colors", "red", "blue", "green"], ["letters", "a", "b", "c"], "foo"] 
3.0.0 :020 > a.assoc("letters")
 => ["letters", "a", "b", "c"] 
3.0.0 :021 > a.assoc("foo")
 => nil 
 
 #at - return the element at index
 3.0.0 :022 > a = ["a","b","c","d","e"]
 => ["a", "b", "c", "d", "e"] 
3.0.0 :023 > a.at(0)
 => "a" 

#By using binary search, finds a value from this array which meets the given condition in O(log n) where n is the size of the array.3.0.0 :024 > ary = [0,4,7,10,12]
 => [0, 4, 7, 10, 12] 
3.0.0 :025 > ary.bsearch {|x| x >= 4}
 => 4 
3.0.0 :026 > ary.bsearch {|x| x>= 6}
 => 7 
 
 #clear - remove all elements
 3.0.0 :029 > a = ["a","b","c","d","e"]
 => ["a", "b", "c", "d", "e"] 
3.0.0 :030 > a.clear
 => [] 

 #combination(n) → Enumerator
When invoked with a block, yields all combinations of length n of elements from the array and then returns the array itself.
3.0.0 :032 > a.combination(1).to_a
 => [[1], [2], [3], [4]] 
3.0.0 :034 > a.combination(2).to_a
 => [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]] 
3.0.0 :035 > a.combination(3).to_a
 => [[1, 2, 3], [1, 2, 4], [1, 3, 4], [2, 3, 4]] 
3.0.0 :036 > a.combination(4).to_a
 => [[1, 2, 3, 4]] 

# compact → Returns a copy of self with all nil elements removed
3.0.0 :037 > ["a",nil,"1",nil]
 => ["a", nil, "1", nil] 
3.0.0 :038 > ["a",nil,"1",nil].compact
 => ["a", "1"] 
3.0.0 :039 > ["a",nil,"1",nil].compact!
 => ["a", "1"] 
3.0.0 :040 > ["a","1"].compact!
 => nil 
 
#concat(other_ary1, other_ary2, ...) → Appends the elements of other_arys to self.
3.0.0 :043 > a.concat( [5,6,7])
=> [1, 2, 3, 4, 5, 6, 7] 
3.0.0 :045 > a.concat(a, a)
 => [1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7] 
 
 #count - returns the number of elements
 3.0.0 :046 > ary = [1,2,4,2]
 => [1, 2, 4, 2] 
 3.0.0 :047 > ary.count
 => 4 
3.0.0 :048 > ary.count(2)
 => 2 
3.0.0 :049 > ary.count(4)
 => 1 
3.0.0 :050 > ary.count {|x| x&2==0}
 => 2 

#cycle - calls the given block for each element n times or forever if nil is given.
3.0.0 :053 > a.cycle(2) {|x| puts x}
a
b
c
a
b
c
 => nil 
 
 # delete(obj) - Deletes all items from self that are equal to obj.
 3.0.0 :054 > a = ["a","b","b","b","c"]
 => ["a", "b", "b", "b", "c"] 
3.0.0 :055 > a.delete("b")
 => "b" 
3.0.0 :056 > a
 => ["a", "c"] 
3.0.0 :057 > a.delete("z")
 => nil 

# delete_at(index) - Deletes the element at the specified index, returning that element, or nil if the index is out of range.
3.0.0 :060 > a.delete_at(2)
 => "dog" 
3.0.0 :061 > a
 => ["ant", "cat"] 
3.0.0 :062 > a.delete_at(9)
 => nil 

#delete_if - delete element for which block evaluates to true
scores = [ 97,45,75,65]
 => [97, 45, 75, 65] 
3.0.0 :064 > scores.
 scores.delete_if {|score| score < 80 }

#dig - Extracts the nested value specified by the sequence of idx objects by calling dig at each step, returning nil if any intermediate step is nil.
3.0.0 :074 > a.dig(0, 1, 1)
 => 3 
3.0.0 :075 > a.dig(1, 2, 3)
 => nil 
 
 #drop - Drops first n elements from ary and returns the rest of the elements in an array
 3.0.0 :076 > a = [1, 2, 3, 4, 5, 0]
 => [1, 2, 3, 4, 5, 0] 
3.0.0 :077 > a.drop(3)
 => [4, 5, 0] 
 
 3.0.0 :079 > a.drop_while {|i| i < 3 }
 => [3, 4, 5, 6] 
 
 #each - Calls the given block once for each element in self, passing that element as a parameter. Returns the array itself.
 3.0.0 :080 > a = ["a" , "b", "c"]
 => ["a", "b", "c"] 
3.0.0 :081 > a.each {|x| print x, " -- " }
a -- b -- c --  => ["a", "b", "c"] 
3.0.0 :082 > a.each_index {|x| print x, " -- " }
0 -- 1 -- 2 --  => ["a", "b", "c"] 


#fetch - Tries to return the element at position index, but throws an IndexError exception if the referenced index lies outside of the array bounds. This error can be prevented by supplying a second argument, which will act as a default value.
3.0.0 :085 > a = [ 11, 22, 33, 44]
 => [11, 22, 33, 44] 
3.0.0 :086 > a.fetch(1)
 => 22 
3.0.0 :087 > a.fetch(-1)
 => 44 
3.0.0 :088 > a.fetch(4, 'dog')
 => "dog" 

#fill
3.0.0 :089 > a = ["","","",""]
 => ["", "", "", ""] 
3.0.0 :090 > a.fill("x")
 => ["x", "x", "x", "x"] 
3.0.0 :091 > a.fill("z",2, 2)
 => ["x", "x", "z", "z"] 
3.0.0 :092 > a.fill("y", 0..1)
 => ["y", "y", "z", "z"] 
3.0.0 :093 > a.fill {|i| i*i}
 => [0, 1, 4, 9] 

#filter - Returns a new array containing all elements of ary for which the given block returns a true value.
 => [0, 1, 4, 9] 
3.0.0 :094 > [1,2,3,4,5].select {|num| num.even? }
 => [2, 4] 
3.0.0 :095]> a = %w[a b c d e f]
 => ["a", "b", "c", "d", "e", "f"] 
3.0.0 :096 > a.select {|v| v=~ /[aeiou]/ }
 => ["a", "e"] 

#first - returns the first element, or the first n elements, of the array.
3.0.0 :097 > a = ["q", "r", "s", "t"]
 => ["q", "r", "s", "t"] 
3.0.0 :098 > a.first
 => "q" 
3.0.0 :099 > a.first(2)
 => ["q", "r"] 
3.0.0 :100 > 

#flatten - returns a new array that is one-dimensional flattening of self(recursive)
3.0.0 :100 > s = [1,2,3]
 => [1, 2, 3] 
3.0.0 :101 > t=[4,5,6, [7,8]]
 => [4, 5, 6, [7, 8]] 
3.0.0 :102 > a=[s,t,9,10]
 => [[1, 2, 3], [4, 5, 6, [7, 8]], 9, 10] 
3.0.0 :103 > a.flatten
 => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 
 
  include?(object) → true or false click to toggle source

Returns true if the given object is present in self (that is, if any element == object), otherwise returns false.
3.0.0 :104 > a=["a","b","c"]
 => ["a", "b", "c"] 
3.0.0 :105 > a.include?("b")
 => true 
3.0.0 :106 > a.include?("z")
 => false 
 
 #replace - replaces the content
 3.0.0 :107 > a = [ "a", "b", "c", "d", "e"]
 => ["a", "b", "c", "d", "e"] 
3.0.0 :108 > a.replace([ "x", "y", "z" ])
 => ["x", "y", "z"] 
 
 #insert - insert the value before the element with given index
 3.0.0 :110 > a = %w{a b c d }
 => ["a", "b", "c", "d"] 
3.0.0 :111 > a.insert(2, 99)
 => ["a", "b", 99, "c", "d"] 


#to_s → string
Creates a string representation of self, by calling inspect on each element.
3.0.0 :116 > ['a','b','c'].to_s
 => "[\"a\", \"b\", \"c\"]" 

# intersection(other_ary1, other_ary2, ...) → new_ary click to toggle source
Set Intersection — Returns a new array containing unique elements common to self and other_arys. Order is preserved from the original array.
It compares elements using their hash and eql? methods for efficiency.
3.0.0 :117 > [1,1,3,5].intersection([3,21])
 => [3] 
3.0.0 :118 > ["a", "b", "z"].intersection(["a","b","c"],["b"])
 => ["b"] 


# join(separator=$,) → Returns a string created by converting each element of the array to a string, separated by the given separator.

 3.0.0 :121 > [ "a", "b", "c"].join
 => "abc" 
3.0.0 :122"> ["a,"b","c"].join("-")
3.0.0 :123">  ^C
3.0.0 :122 > [ "a", "b" , "c" ].join("-")
 => "a-b-c" 
 
 # keep_if → Enumerator
Deletes every element of self for which the given block evaluates to false, and returns self.

3.0.0 :123 > a = %w[a b c d e f]
 => ["a", "b", "c", "d", "e", "f"] 
3.0.0 :124 > a.keep_if {|v| v =~ /[aeiou]/}
 => ["a", "e"] 
3.0.0 :125 > a
 => ["a", "e"] 
 
 
 #last(n) → new_ary
  Returns the last element(s) of self. If the array is empty, the first form returns nil.
  3.0.0 :126 > a = [ "w", "x", "y", "z"]
 => ["w", "x", "y", "z"] 
3.0.0 :127 > a.last
 => "z" 
3.0.0 :128 > a.last(2)
 => ["y", "z"] 

length - 3.0.0 :129 > [1,2,3,4,5].length
 => 5 
3.0.0 :130 > [].length
 => 0 

#map -  map {|item| block} 
Invokes the given block once for each element of self.
Creates a new array containing the values returned by the block.
3.0.0 :131 > a.map! {|x| x + "!"}
 => ["w!", "x!", "y!", "z!"] 
 
 #max(n) {|a, b| block} → array
Returns the object in ary with the maximum value. The first form assumes all objects implement Comparable; the second uses the block to return a <=> b.
  => ["", "x", "y!", "z!"] 
3.0.0 :134 > ary = %w(abc abcd abcde)
 => ["abc", "abcd", "abcde"] 
3.0.0 :135 > ary.max
 => "abcde" 
3.0.0 :136 > ary.max(2)
 => ["abcde", "abcd"] 
3.0.0 :137 > ary.max {|a, b| a.length <=> b.length}
 => "abcde" 

# min(n) {| a,b | block } → array
Returns the object in ary with the minimum value. The first form assumes all objects implement Comparable; the second uses the block to return a <=> b

3.0.0 :138 > ary = %w(goku vegeta gohan trunks)
 => ["goku", "vegeta", "gohan", "trunks"] 
3.0.0 :139 > ary.min
 => "gohan" 
3.0.0 :140 > ary.min {|a, b| a.length <=> b.length}
 => "goku" 
3.0.0 :141 > ary.min(2)
 => ["gohan", "goku"] 
3.0.0 :142 > ary.min(2) {|a, b| a.length <=> b.length}
 => ["goku", "gohan"] 


# pack( aTemplateString ) → 
Packs the contents of arr into a binary sequence according to the directives in a TemplateString.
3.0.0 :143 > a = ["a", "b", "c"]
 => ["a", "b", "c"] 
3.0.0 :144 > n = [65,66,67]
 => [65, 66, 67] 
3.0.0 :145 > a.pack("A3A3A3")
 => "a  b  c  " 
3.0.0 :146 > n.pack("ccc")
 => "ABC" 
3.0.0 :147

# permutation(n) → Enumerator

When invoked with a block, yield all permutations of length n of the elements of the array, then return the array itself.

If n is not specified, yield all permutations of all elements.

The implementation makes no guarantees about the order in which the permutations are yielded.

If no block is given, an Enumerator is returned instead.

3.0.0 :147 > a = [1,2,3]
 => [1, 2, 3] 
3.0.0 :148 > a.permutation.to_a
 => [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] 
3.0.0 :149 > a.permutation(1).to_a
 => [[1], [2], [3]] 
3.0.0 :150 > a.permutation(2).to_a
 => [[1, 2], [1, 3], [2, 1], [2, 3], [3, 1], [3, 2]] 
3.0.0 :151 > a.permutation(3).to_a
 => [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] 
3.0.0 :152 > a.permutation(0).to_a
 => [[]] 
3.0.0 :153 > a.permutation(5).to_a
 => [] 


 pop(n) → new_ary
Removes the last element from self and returns it, or nil if the array is empty.
If a number n is given, returns an array of the last n elements (or less) just like array.slice!(-n, n) does
3.0.0 :154 > a = ["a","b","c","d"]
 => ["a", "b", "c", "d"] 
3.0.0 :155 > a.pop
 => "d" 
3.0.0 :156 > a.pop(2)
 => ["b", "c"] 
3.0.0 :157 > a
 => ["a"] 

# product(other_ary, ...) {|p| block} → ary
Returns an array of all combinations of elements from all arrays.
The length of the returned array is the product of the length of self and the argument arrays.

3.0.0 :166 > [1,2,3].product([4,5])
 => [[1, 4], [1, 5], [2, 4], [2, 5], [3, 4], [3, 5]] 
3.0.0 :167 > [1,2].product([1,2])
 => [[1, 1], [1, 2], [2, 1], [2, 2]] 
3.0.0 :168 > [1,2].product([3,4],[5,6])
 => [[1, 3, 5], [1, 3, 6], [1, 4, 5], [1, 4, 6], [2, 3, 5], [2, 3, 6], [2, 4, 5], [2, 4, 6]] 
3.0.0 :169 > [1,2].product()
 => [[1], [2]] 
3.0.0 :170 > [1,2].product([])
3.0.0 :171 > 
 => [] 
 
 #append(obj, ...) → ary
Append — Pushes the given object(s) on to the end of this array. This expression returns the array itself, so several appends may be chained together.
3.0.0 :172 > a = ["a","b","c"]
 => ["a", "b", "c"] 
3.0.0 :173 > a.push("d","e","f")
 => ["a", "b", "c", "d", "e", "f"] 
3.0.0 :174 > [1, 2, 3].push(4).push(5)
 => [1, 2, 3, 4, 5] 

#rassoc - Searches through the array whose elements are also arrays.

 => [[1, "one"], [2, "two"], [3, "three"], ["ii", "two"]] 

3.0.0 :177 > a.rassoc("two")
 => [2, "two"] 
3.0.0 :178 > a.rassoc("ii")
 => nil 
3.0.0 :179 > a.rassoc("three")
 => [3, "three"] 
3.0.0 :180 > a.rassoc("one")
 => [1, "one"] 
3.0.0 :181 > 

#Array#reject() : reject() is a Array class method which returns new array containing the items in the array for which the given block is not true
3.0.0 :181 > a=[18,22,33,3,5,6]
 => [18, 22, 33, 3, 5, 6] 
3.0.0 :182 > b = [1,4,1,1,88,9]
 => [1, 4, 1, 1, 88, 9] 
3.0.0 :183 > puts " #{a.reject {|num| num > 10 }}"
 [3, 5, 6]
 => nil 
3.0.0 :184 > puts " #{a.reject {|num| num < 10 }}"
 [18, 22, 33]
 => nil 

# repeated_combination(n) → Enumerator
When invoked with a block, yields all repeated combinations of length n of elements from the array and then returns the array itself.

3.0.0 :186 > a.repeated_combination(1).to_a
 => [[1], [2], [3]] 
3.0.0 :187 > a.repeated_combination(2).to_a
 => [[1, 1], [1, 2], [1, 3], [2, 2], [2, 3], [3, 3]] 
3.0.0 :188 > a.repeated_combination(3).to_a
 => [[1, 1, 1], [1, 1, 2], [1, 1, 3], [1, 2, 2], [1, 2, 3], [1, 3, 3], [2, 2, 2], [2, 2, 3], [2, 3, 3], [3, 3, 3]] 
3.0.0 :189 > 


#replace(other_ary) → ary click to toggle source
Replaces the contents of self with the contents of other_ary, truncating or expanding if necessary.

3.0.0 :189 > a=["a","b","c","d","e"]
 => ["a", "b", "c", "d", "e"] 
3.0.0 :190 > a.replace(["x","y","z"])
 => ["x", "y", "z"] 

# reverse → Returns a new array containing self's elements in reverse order.
3.0.0 :197 > ["a","b","c"].reverse
 => ["c", "b", "a"] 
3.0.0 :198 > [1].reverse
 => [1] 
3.0.0 :199 > a = ["a","b","c"]
 => ["a", "b", "c"] 
3.0.0 :200 > a.reverse
 => ["c", "b", "a"] 
3.0.0 :201 > a
 => ["a", "b", "c"] 
3.0.0 :202 > a.reverse!
 => ["c", "b", "a"] 
3.0.0 :203 > a
 => ["c", "b", "a"] 

3.0.0 :001 > a=["a","b","c"]
 => ["a", "b", "c"] 
3.0.0 :002 > a.reverse_each {|x| print x, " "}
c b a  => ["a", "b", "c"] 

# rindex → Enumerator
Returns the index of the last object in self == to obj.
If a block is given instead of an argument, returns the index of the first object for which the block returns true, starting from the last object.
Returns nil if no match is found.

 => ["a", "b", "b", "b", "c"] 
3.0.0 :004 > a.rindex("b")
 => 3 
3.0.0 :005 > a.rindex("a")
 => 0 
3.0.0 :006 > a.rindex {|x| x == "b"}
 => 3 

# rotate(count=1) → Returns a new array by rotating self so that the element at count is the first element of the new array.
If count is negative then it rotates in the opposite direction, starting from the end of self where -1 is the last element.

3.0.0 :007 > a = ["a","b","c","d"]
 => ["a", "b", "c", "d"] 
3.0.0 :008 > a.rotate
 => ["b", "c", "d", "a"] 
3.0.0 :009 > a.rotate(2)
 => ["c", "d", "a", "b"] 
3.0.0 :010 > a.rotate(-3)
 => ["b", "c", "d", "a"] 
 
 3.0.0 :012 > a.rotate!
 => ["b", "c", "d", "a"] 
3.0.0 :013 > a
 => ["b", "c", "d", "a"] 
3.0.0 :014 > a.rotate!(3)
 => ["a", "b", "c", "d"] 

# sample(n, random: rng) → new_ary
Choose a random element or n random elements from the array.
The elements are chosen by using random and unique indices into the array in order to ensure that an element doesn't repeat itself unless the array already contained duplicate elements.

3.0.0 :021 > a.sample
 => 2 
3.0.0 :022 > a.sample(4)
 => [4, 1, 2, 3]
 
 # select
Returns a new array containing all elements of ary for which the given block returns a true value.
3.0.0 :024 > [1,2,3,4,5].select {|num| num.even?}
 => [2, 4] 
3.0.0 :025 > [1,2,3,4,5].select {|num| num.odd?}
 => [1, 3, 5] 
3.0.0 :026]> a = %w[ a b c d e f ]
 => ["a", "b", "c", "d", "e", "f"] 
3.0.0 :027 > a.select {|v| v =~ /[aeiou]/ }
 => ["a", "e"] 

#shift → obj or nil click to toggle source
shift(n) → new_ary
Removes the first element of self and returns it (shifting all other elements down by one). Returns nil if the array is empty.

.0.0 :026]> a = %w[ a b c d e f ]
 => ["a", "b", "c", "d", "e", "f"] 
3.0.0 :027 > a.select {|v| v =~ /[aeiou]/ }
 => ["a", "e"] 
3.0.0 :028 > args = ["-m","-q","filename"]
 => ["-m", "-q", "filename"] 
3.0.0 :029 > args.shift
 => "-m" 
3.0.0 :030 > args
 => ["-q", "filename"] 
3.0.0 :031 > args = ["-m","-q","filename"]
 => ["-m", "-q", "filename"] 
3.0.0 :032 > args.shift(2)
 => ["-m", "-q"] 
3.0.0 :033 > args
 => ["filename"] 

#shuffle - returns a new array with elements of self shuffled

3.0.0 :034 > a = [ 1,2,3]
 => [1, 2, 3] 
3.0.0 :035 > a.shuffle!
 => [2, 3, 1] 
3.0.0 :036 > a
 => [2, 3, 1] 
 
 .0 :037 > a.shuffle!(random: Random.new(1))
 => [2, 1, 3] 

#Element Reference — Returns the element at index, or returns a subarray starting at the start index and continuing for length elements, or returns a subarray specified by range of indices.
Negative indices count backward from the end of the array (-1 is the last element). For start and range cases the starting index is just before an element. Additionally, an empty array is returned when the starting index for an element range is at the end of the array.

3.0.0 :042 > a.slice(1)
 => "b" 
3.0.0 :043 > a
 => ["a", "b", "c", "d", "e", "f"] 
3.0.0 :044 > a.slice(-1)
 => "f" 
3.0.0 :045 > a.slice(1,4)
 => ["b", "c", "d", "e"] 
3.0.0 :047 > a.slice!(-1)
 => "f" 
3.0.0 :048 > a
 => ["a", "b", "c", "d", "e"] 
3.0.0 :049 > a.slice!(100)
 => nil 

Sort - Returns a new array created by sorting self.
3.0.0 :050 > a = ["d","a","e","c","b"]
 => ["d", "a", "e", "c", "b"] 
3.0.0 :051 > a.sort
 => ["a", "b", "c", "d", "e"] 
3.0.0 :052?> a.sort (|a, b| b<=>a}
3.0.0 :053?>   ^C
3.0.0 :052 > a
 => ["d", "a", "e", "c", "b"] 
3.0.0 :053 > a.sort.reverse!
 => ["e", "d", "c", "b", "a"] 
 
3.0.0 :057 > n.sort!
 => [1, 2, 3, 4, 5, 6] 
3.0.0 :058 > n.sort! {|a, b| b <=> a}
 => [6, 5, 4, 3, 2, 1] 

#sum - returns the sum of elements.
3.0.0 :061 > [].sum(0.0)
 => 0.0 
3.0.0 :062 > [1,2,3].sum
 => 6 
3.0.0 :063 > [3,4,5,6].sum
 => 18 
3.0.0 :064 > [2.5,3.0].sum(0.0) {|e| e * e}
 => 15.25 

# take(n) → 
Returns first n elements from the array.
If a negative number is given, raises an ArgumentError.

3.0.0 :067 > a.take(3)
 => [1, 2, 3] 
3.0.0 :068 > a.take(6)
 => [1, 2, 3, 4, 5, 0] 
 
 
 # take_while - pass elements to the block until the block returns nil or false
then stops iterating and returns an array of all prior elements.
3.0.0 :069 > a = [1,2,3,4,5,0]
 => [1, 2, 3, 4, 5, 0] 
3.0.0 :070 > a.take_while{|i| i < 3}
 => [1, 2] 


#to_h {|item| block } → hash
Returns the result of interpreting ary as an array of [key, value] pairs.

3.0.0 :071 > [[:foo,:bar], [1,2]].to_h
 => {:foo=>:bar, 1=>2} 
 
 If a block is given, the results of the block on each element of the array will be used as pairs.
 3.0.0 :072 > ["foo","bar"].to_h {|s| [s.ord, s]}
 => {102=>"foo", 98=>"bar"} 
 
#transpose - Assumes that self is an array of arrays and transposes the rows and columns.
  => [[1, 2], [3, 4], [5, 6]] 
3.0.0 :074 > a.transpose
 => [[1, 3, 5], [2, 4, 6]] 

# union(other_ary1, other_ary2, ...) 
Set Union — Returns a new array by joining other_arys with self, excluding any duplicates and preserving the order from the given arrays.

 3.0.0 :077 > ["a","b","c"].union(["a","b","c"])
 => ["a", "b", "c"] 
3.0.0 :078 > ["a","b","c"].union(["a","b","c","e","f"])
 => ["a", "b", "c", "e", "f"] 

#uniq {|item| ...} → new_ary
Returns a new array by removing duplicate values in self.
If a block is given, it will use the return value of the block for comparison.
It compares values using their hash and eql? methods for efficiency.
self is traversed in order, and the first occurrence is kept.

3.0.0 :079 > a = ["a","a","b","b","c"]
 => ["a", "a", "b", "b", "c"] 
3.0.0 :080 > a.uniq
 => ["a", "b", "c"] 
3.0.0 :081 > a
 => ["a", "a", "b", "b", "c"] 
3.0.0 :082 > a.uniq!
 => ["a", "b", "c"] 
3.0.0 :083 > a
 => ["a", "b", "c"] 

3.0.0 :084 > c = [["student","sam"], ["student","george"], ["teacher","matz"]]
 => [["student", "sam"], ["student", "george"], ["teacher", "matz"]] 
3.0.0 :085 > c.uniq! {|s| s.first}
 => [["student", "sam"], ["teacher", "matz"]] 

#prepend(obj, ...) →
Prepends objects to the front of self, moving other elements upwards. See also Array#shift for the opposite effect.

3.0.0 :087 > a.unshift("a")
 => ["a", "b", "c", "d"] 
3.0.0 :088 > a
 => ["a", "b", "c", "d"] 
3.0.0 :089 > a.unshift(1,2)
 => [1, 2, "a", "b", "c", "d"] 
 
 # values_at(selector, ...) → 
Returns an array containing the elements in self corresponding to the given selector(s).
The selectors may be either integer indices or ranges.
 3.0.0 :091 > a = %w{ a b c d e f }
 => ["a", "b", "c", "d", "e", "f"] 
3.0.0 :093 > a.values_at(1,3,5)
 => ["b", "d", "f"] 
3.0.0 :094 > a.values_at(1,6)
 => ["b", nil] 
3.0.0 :095 > a.values_at(1..4)


#zip(arg, ...) → 
zip(arg, ...) {|arr| block} → nil

Converts any arguments to arrays, then merges elements of self with corresponding elements from each argument.
This generates a sequence of ary.size n-element arrays, where n is one more than the count of arguments.
If the size of any argument is less than the size of the initial array, nil values are supplied.
If a block is given, it is invoked for each output array, otherwise an array of arrays is returned.
3.0.0 :096 > a = [4,5,6]
 => [4, 5, 6] 
3.0.0 :097 > b = [7,8,9]
 => [7, 8, 9] 
3.0.0 :098 > [1,2,3].zip(a,b)
 => [[1, 4, 7], [2, 5, 8], [3, 6, 9]] 
3.0.0 :099 > [1,2].zip(a, b)
 => [[1, 4, 7], [2, 5, 8]] 


2.7.0 :005 > a = Array.new(40)
 => 
[nil,                                                  
...                                                    
2.7.0 :006 > a.size
 => 40 
2.7.0 :007 > a.length
 => 40 

2.7.0 :008 > arr = ['a','b','c']
 => ["a", "b", "c"] 
2.7.0 :009 > puts "#{arr}"
["a", "b", "c"]
 => nil                                                
2.7.0 :010 > puts "SIze is #{arr.size}"
SIze is 3
 => nil   
 
 2.7.0 :011 > str = ["Chandigarh","Ambala","Ferozpur"]
 => ["Chandigarh", "Ambala", "Ferozpur"] 
2.7.0 :012 > puts str[1]
Ambala
 => nil 
 
 2.7.0 :014 > puts str[1,2]
Ambala
Ferozpur                                                                            
 => nil     
 
 2.7.0 :016 > str.first
 => "Chandigarh" 
2.7.0 :017 > str.last
 => "Ferozpur" 

2.7.0 :018 > str.take(2)
 => ["Chandigarh", "Ambala"]
 
 2.7.0 :020 > str.drop(1)
 => ["Ambala", "Ferozpur"] 
2.7.0 :021 > str
 => ["Chandigarh", "Ambala", "Ferozpur"] 
2.7.0 :022 > 

2.7.0 :022 > str.pop(2)
 => ["Ambala", "Ferozpur"] 
2.7.0 :023 > str
 => ["Chandigarh"] 
2.7.0 :024 > 
2.7.0 :024 > str.shift
 => "Chandigarh" 

2.7.0 :025 > str.push("Chandigarh","Ambala","Ferozpur")
 => ["Chandigarh", "Ambala", "Ferozpur"] 


ary |
Set Union — Returns a new array by joining ary with other_ary, excluding any duplicates and preserving the order from the given arrays.
It compares elements using their hash and eql? methods for efficiency.

3.0.0 :100 > ["a","b","c"] | ["c","d","a"]
 => ["a", "b", "c", "d"] 
3.0.0 :101 > ["c","d","a"] | ["a","b","c"]
 => ["c", "d", "a", "b"] 


 => "a" 
2.7.0 :031 > arr.unshift(2)
 => [2, "b"] 
2.7.0 :032 > 

2.7.0 :032 > str.reverse
 => ["Ferozpur", "Ambala", "Chandigarh"] 

2.7.0 :033 > arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
 => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 
2.7.0 :034 > arr.select {|x| x > 4}
 => [5, 6, 7, 8, 9, 10] 

2.7.0 :035 > str.include?("Chandigarh")
 => true 
 
 2.7.0 :036 > arr.join("*")
 => "1*2*3*4*5*6*7*8*9*10" 

2.7.0 :037 > str.each do |element|
2.7.0 :038 >   puts element
2.7.0 :039 > end
Chandigarh
Ambala                                                                        
Ferozpur                                                                      
 => ["Chandigarh", "Ambala", "Ferozpur"]         
 
 2.7.0 :043 > arr.map { |element| element * 2 }
 => [2, 4, 6, 8, 10, 12, 14, 16, 18, 20] 

2.7.0 :046 > str = arr.map { |element| element * 2 }
 => [2, 4, 6, 8, 10, 12, 14, 16, 18, 20] 
2.7.0 :047 > puts str
2
4                                            
6                                            
8                                            
10                                           
12                                           
14                                           
16                                           
18                                           
20                                           
 => nil 
 
 2.7.0 :048 > arr = [1,2,3,4,5,1,2,3,4,5,6,7]
 => [1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 6, 7] 
2.7.0 :049 > arr.uniq
 => [1, 2, 3, 4, 5, 6, 7] 

 => [0, 1, 2, 3, 4] 
2.7.0 :051 > array.concat([5, 6, 7], [8, 9, 10])
 => [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 
2.7.0 :052 > array
 => [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 
2.7.0 :053 > 


2.7.0 :053 > fruits = { coconut: 1, apple: 2, banana: 3 }
 => {:coconut=>1, :apple=>2, :banana=>3} 
2.7.0 :054 > fruits[:orange] = 4
 => 4 
 
 2.7.0 :055 > fruits[:orange]
 => 4 
2.7.0 :056 > fruits[:peach]
 => nil 


2.7.0 :057 > city = { Chandigarh: 1, Delhi: 2, Ambala: 3}
 => {:Chandigarh=>1, :Delhi=>2, :Ambala=>3} 
2.7.0 :058 > country = { India: 1, Australia: 2, Spain: 3}
 => {:India=>1, :Australia=>2, :Spain=>3} 
2.7.0 :059 > city.merge!(country)
 => {:Chandigarh=>1, :Delhi=>2, :Ambala=>3, :India=>1, :Australia=>2, :Spain=>3} 


2.7.0 :060 > dictionary = {
2.7.0 :061 >   opportunity: [
2.7.0 :062 >     "A set of circumstances that make it possible",
2.7.0 :063 >     "a situation for attainment of goal"
2.7.0 :064 >   ],
2.7.0 :065 >   creativity: [
2.7.0 :066 >     "ability to create",
2.7.0 :067 >     "new ideas merge from"
2.7.0 :068 >   ]
2.7.0 :069 > }
 => 
{:opportunity=>                                                                       
...               

2.7.0 :070 > dictionary[:creativity][1]
 => "new ideas merge from" 
2.7.0 :071 > dictionary[:creativity][0]
 => "ability to create" 

2.7.0 :072 > {c: 1, b: 2}.sort
 => [[:b, 2], [:c, 1]] 
2.7.0 :073 > {c: 1, b: 2}.sort_by(&:last)
 => [[:c, 1], [:b, 2]] 

2.7.0 :084 > dictionary = {
2.7.0 :085 >   opportunity: [
2.7.0 :086 >     "A set of circumstances that make it possible",
2.7.0 :087 >     "a situation for attainment of goal"
2.7.0 :088 >   ],
2.7.0 :089 >   creativity: [
2.7.0 :090 >     "ability to create",
2.7.0 :091 >     "new ideas merge from"
2.7.0 :092 >   ]
2.7.0 :093 > }.keys
 => [:opportunity, :creativity] 
2.7.0 :094 > dictionary = {
2.7.0 :095 >   opportunity: [
2.7.0 :096 >     "A set of circumstances that make it possible",
2.7.0 :097 >     "a situation for attainment of goal"
2.7.0 :098 >   ],
2.7.0 :099 >   creativity: [
2.7.0 :100 >     "ability to create",
2.7.0 :101 >     "new ideas merge from"
2.7.0 :102 >   ]
2.7.0 :103 > }.values
 => [["A set of circumstances that make it possible", "a situation for attainment of goal"], ["ability to create", "new ideas merge from"]] 

super inheritance module eigne class singelton
self

2.7.0 :001 > proc = Proc.new{ puts "I am the proc method" }
 => #<Proc:0x000055dc16f40068 (irb):1> 
2.7.0 :002 > proc.call
I am the proc method
 => nil    
 
 2.7.0 :003 > def block_method
2.7.0 :004 >   puts "We are in the method"
2.7.0 :005 > end
 => :block_method 
2.7.0 :006 > block_method { puts "Block is called" }
We are in the method
 => nil      
 
 2.7.0 :007 > def my_method
2.7.0 :008 >   puts "we are in the method"
2.7.0 :009 >   yield 
2.7.0 :010 >   puts "we are back in method"
2.7.0 :011 > end
 => :my_method 
2.7.0 :012 > my_method { puts "Block is called"}
we are in the method
Block is called                                                       
we are back in method                                                 
 => nil      
 
 2.7.0 :014 > def my_block
2.7.0 :015 >   yield 2 
2.7.0 :016 >   yield 3
2.7.0 :017 > end
 => :my_block 
2.7.0 :018 > my_block {|x| puts "parameter is: #{x}" }
parameter is: 2
parameter is: 3                                                          
 => nil 
 
 ruby introduces proc so that we can pass blocks around it.
 
 2.7.0 :024 > proc = Proc.new{|x| print x*2}
 => #<Proc:0x000055dc178a71b0 (irb):24> 
2.7.0 :025 > [4,3,2,1].each(&proc)
8642 => [4, 3, 2, 1] 
2.7.0 :026 > [4,3,2,1].each(&proc)

2.7.0 :042 > l = -> {puts "This is lambda"}
 => #<Proc:0x000055dc1727e428 (irb):42 (lambda)> 
2.7.0 :043 > l.call
This is lambda
 => nil                                                       
2.7.0 :

2.7.0 :042 > l = -> {puts "This is lambda"}
 => #<Proc:0x000055dc1727e428 (irb):42 (lambda)> 
2.7.0 :043 > l.call
This is lambda
 => nil                                                       
2.7.0 :044 > l = lambda {|n| "lambda one was called with #{n}"}
 => #<Proc:0x000055dc17655588 (irb):44 (lambda)> 
2.7.0 :045 > l.call(2)
 => "lambda one was called with 2" 
2.7.0 :046 > 


module Student
  C = 10;
  def Student.portal
    puts "Welcome students!"
  end 
  def Student.tutorial
    puts "Welcome to the tutorials"
  end
  def Student.topic
    puts "Topic of respective topics!"
  end
end

puts Student::C  
Student.portal 
Student.tutorial
Student.topic

itsacheckmate@itscheckmate:~/Practise$ r
uby my.rb
10
Welcome students!
Welcome to the tutorials
Topic of respective topics!



module Student
  def portal
    puts "Welcome to the portal!"
  end

  def tutorial
    puts "Welcome to the tutorial"
  end

  def topic
    puts "These are the respective topics"
  end
end

class Teacher
    include Student
    def name
        puts "I am teacher of the respective students"
    end
end

ob = Teacher.new
ob.portal
ob.tutorial
ob.topic
ob.name

[Running] ruby "/home/itsacheckmate/Practise/my.rb"
Welcome to the portal!
Welcome to the tutorial
These are the respective topics
I am teacher of the respective students

module Name
  def cat  
    puts "I have a cat"
  end
  def dog
    puts "I have a dog"
  end
end

module Animal
  def g1
    puts "Hello"
  end
  def g2
    puts "Hello2"
  end
end

class Mixin
  include Name
  include Animal
  def s1
    puts "Calling method of module
   using mixin"
end
end

obj1 = Mixin.new
obj1.cat   
obj1.dog 
obj1.g1 
obj1.g2

itsacheckmate@itscheckmate:~/Practise$ ruby my.rb
I have a cat
I have a dog
Hello
Hello2
itsache


 => ["Paul", "John", "Peter"] 
2.7.0 :009 > names = ["paul", "john", "peter"]
 => ["paul", "john", "peter"] 
2.7.0 :010 > names_capitalize = names.map do |name|
2.7.0 :011 >   name.capitalize
2.7.0 :012 > end
 => ["Paul", "John", "Peter"] 
2.7.0 :013 > 


2.7.0 :013 > products = [
2.7.0 :014 >   {name: "Mac Book Pro", active: true, price: 1599.99 },
2.7.0 :015 >   {name: "Iwatch", active: false, price: 59.99 },
2.7.0 :016 >   {name: "Ipad Pro", active: true, price: 699.99 },
2.7.0 :017 > ]
 => 
[{:name=>"Mac Book Pro", :active=>true, :price=>1599.99}, 

2.7.0 :018 > p = products.select{ |product| product[:active] }
 => 
[{:name=>"Mac Book Pro", :active=>true, :price=>1599.99},                       
...                                                                             
2.7.0 :019 > p
 => 
[{:name=>"Mac Book Pro", :active=>true, :price=>1599.99},                       
 {:name=>"Ipad Pro", :active=>true, :price=>699.99}]     
 
 2.7.0 :022 > first_axctive_product = products.detect { |product| product[:active
]}
 => {:name=>"Mac Book Pro", :active=>true, :price=>1599.99} 


products = [
    { name: 'Mac Book Pro', active: true, price: '1599.99' },
    { name: 'iWatch', active: false, price: '599.99' },
    { name: 'iPad Pro', active: true, price: '699.99' },
  ]
  nb_products = products.count { |product| product.price > 1000 }
  puts nb_products 
  
  2.7.0 :010 > while bomb_timer >= 0
2.7.0 :011 >   puts bomb_timer 
2.7.0 :013 > end
10
9                                                                             
8                                                                             
7                                                                             
6                                                                             
5                                                                             
4                                                                             
3                                                                             
2                                                                             
1                                                                             
0                                                                             
 => nil                                                                       
2.7.0 :01


2.7.0 :022 > until end_of_time < 20
2.7.0 :023 >   puts end_of_time  
2.7.0 :024 >   end_of_time -= 1
2.7.0 :025 > end
50
49                                                              
48                                                              
47                                                              
46                                                              
45                                                              
44                                                              
43                                                              
42                                                              
41                                                              
40                                                              
39                                                              
38                                                              
37                                                              
36                                                              
35                                                              
34                                                              
33                                                              
32                                                              
31
30
29
28
27
26
25
24
23
22
21
20
 => nil 

2.7.0 :027 > loop do
2.7.0 :028 >   hp -= 2
2.7.0 :029 >   puts "Damage done, hp remaning #{hp}"
2.7.0 :030 >   break if hp <= 0
2.7.0 :031 > end
Damage done, hp remaning 28
Damage done, hp remaning 26                                  
Damage done, hp remaning 24                                  
Damage done, hp remaning 22                                  
Damage done, hp remaning 20                                  
Damage done, hp remaning 18                                  
Damage done, hp remaning 16                                  
Damage done, hp remaning 14                                  
Damage done, hp remaning 12                                  
Damage done, hp remaning 10                                  
Damage done, hp remaning 8                                   
Damage done, hp remaning 6                                   
Damage done, hp remaning 4                         
Damage done, hp remaning 2                         
Damage done, hp remaning 0
 => nil 

2.7.0 :033 > loop do
2.7.0 :034 >   any_number -= 2
2.7.0 :035 >   next if any_number % 2 != 0
2.7.0 :036 >   puts "#{any_number}"
2.7.0 :037 >   break if any_number <= 0
2.7.0 :038 > end
198
196                                                                       
194                                                                       
192                                                                       
190                                                                       
188                                                                       
186                                                                       
184                                                                       
182                                                                       
180                                                                       
178                                                                       
176                                                                       
174                                                                       
172                                                                       
170                                                                       
168                                                                       
166                                                                       
164                                                                       
162
160
158
156
154
152
150
148
146
144
142
140
138
136
134
132
130
128
126
124
122
120
118
116
114
112
110
108
106
104
102
100
98
96
94
92
90
88
86
84
82
80
78
76
74
72
70
68
66
64
62
60
58
56
54
52
50
48
46
44
42
40
38
36
34
32
30
28
26
24
22
20
18
16
14
12
10
8
6
4
2
0
 => nil 


2.7.0 :039 > i = 0
 => 0 
2.7.0 :040 > num = 5
 => 5 
2.7.0 :041 > begin 
2.7.0 :042 >   puts("Inside loop i = #{i}")
2.7.0 :043 >   i += 1
2.7.0 :044 > end until i > num
Inside loop i = 0
Inside loop i = 1                                                        
Inside loop i = 2                                                        
Inside loop i = 3                                                        
Inside loop i = 4                                                        
Inside loop i = 5                                                        
 => nil                                                                  
2.7.0 :

2.7.0 :045 > for i in 0..5 
2.7.0 :046 >   puts "This will print 5 times"
2.7.0 :047 > end
This will print 5 times
This will print 5 times                                                      
This will print 5 times                                                      
This will print 5 times                                                      
This will print 5 times                                                      
This will print 5 times                                                      
 => 0..5  
 
 2.7.0 :066 > for i in 0..5
2.7.0 :067 >   puts "Value of local variable is #{i}"
2.7.0 :068 > end
Value of local variable is 0
Value of local variable is 1                                                    
Value of local variable is 2                                                    
Value of local variable is 3                                                    
Value of local variable is 4                                                    
Value of local variable is 5                                                    
 => 0..5   
 
 name = "rohit"
temp = ''
for i in 1..name.length
    temp += name[name.length - i]
end
puts "Reverse is #{temp}"

itsacheckmate/Practise/my.rb"
Reverse is tihor


2.7.0 :001 > class Foo
2.7.0 :002 >   def method1
2.7.0 :003 >     puts 1
2.7.0 :004 >   end
2.7.0 :005 > end
 => :method1 
2.7.0 :006 > foo = Foo.new
 => #<Foo:0x00005608faf6fca8> 
2.7.0 :007 > foo.method1
1
 => nil                                                
2.7.0 :00

2.7.0 :009 > def foo.method2
2.7.0 :010 >   puts 2
2.7.0 :011 > end
 => :method2 
2.7.0 :012 > foo.method1
1
 => nil                                              
2.7.0 :013 > foo.method2
2
 => nil 
 
 2.7.0 :014 > class Vehicle
2.7.0 :015 >   def wheels
2.7.0 :016 >     puts "There are many wheels"
2.7.0 :017 >   end
2.7.0 :018 > end
 => :wheels 

2.7.0 :019 > train = Vehicle.new
 => #<Vehicle:0x00005608fb64e600> 
2.7.0 :020 > car = Vehicle.new
 => #<Vehicle:0x00005608fae894b0> 

2.7.0 :021 > def car.wheels
2.7.0 :022 >   puts "There are four wheels"
2.7.0 :023 > end
 => :wheels 
 
 2.7.0 :027 > o1="Jaskaran"
 => "Jaskaran" 
2.7.0 :028 > o2 = String.new
 => "" 

2.7.0 :029 > o2 = "Itsacheckmate"
 => "Itsacheckmate" 
2.7.0 :030 > def o2.size
2.7.0 :031 >   return "size does  not matter"
2.7.0 :032 > end
 => :size 
2.7.0 :033 > o1.size
 => 8 
 2.7.0 :034 > puts o2.size
size does  not matter
 => nil       

