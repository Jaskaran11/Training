Ruby is a perfect Object Oriented Programming Language. The features of the object-oriented programming language include −
    Data Encapsulation
    Data Abstraction
    Polymorphism
    Inheritance


#check ruby version
itsacheckmate@itscheckmate:~$ ruby -v
ruby 3.0.0p0 (2020-12-25 revision 95aff21468) [x86_64-linux]

#Basic code practise

itsacheckmate@itscheckmate:~$ irb
3.0.0 :001 > 



#3.0.0 :024 > puts "hello world"
hello world
 => nil 

# multiple line
3.0.0 :001"> puts <<EOF
3.0.0 :002"> this is the first line
3.0.0 :003"> this is the second line
3.0.0 :004"> EOF
3.0.0 :005"> 
this is the first line
this is the second line
 => nil
3.0.0 :007'> print <<'EOC'
3.0.0 :008'> echo hi there
3.0.0 :010 > EOC
echo hi there
 => nil 
 
#In Ruby, nil is a special value that denotes the absence of any value. Nil is an object of NilClass. nil is Ruby's way of referring to nothing or void. 
 
 
 
 Ruby Begin ==> Declares code to be called before the program is run
 Ruby END Statement==>Declares to be called at the end of the program
 
#puts "This line will run in between the code"

END{
    puts "This line will run after "
}
BEGIN{
    puts "This line will run first."
}

Output - [Running] ruby "/home/itsacheckmate/Practise/test.rb"
This line will run first.
This line will run in between the code
This line will run after 

3.0.0 :001'> print <<'EOC'
3.0.0 :002'> echo hi there
3.0.0 :003'> echo lo there
3.0.0 :004'> EOC
echo hi there
echo lo there
 => nil 


print <<"foo", <<"bar"  
	I said foo.
foo
	I said bar.
bar

#Comments in ruby
3.0.0 :006 > #this is a comment
 => nil 
3.0.0 :007 > name = "Jaskaran" #This is a comment
 => "Jaskaran" 
 
 #another way of comment
 =begin
    this is a comment
    this is also a comment
    this is a comment too
rescue => exception
    
end


#Class 
A class is a blueprint from which objects are created. The object is also called as an instance of a class.

3.0.0 :009 > class Vehicle
3.0.0 :010 >   def initialize(id,color,name)
3.0.0 :018 >   end
3.0.0 :019 > end
 => :initialize 
3.0.0 :020 > xveh = Vehicle. new("1","Red","ABC")
Id is : 1
Color is: Red
Name is: ABC

 => #<Vehicle:0x000055dacc6d21d8 @veh_id="1", @veh_color="Red", @veh_name... 
3.0.0 :021 > yveh = Vehicle. new("2","Black","XYZ")
Id is : 2
Color is: Black
Name is: XYZ


itsacheckmate@itscheckmate:~$ irb
3.0.0 :001 > class Person
3.0.0 :002 >   def initialize(id,name,age)
3.0.0 :003 >     @person_id=id
Age is: 23
 => #<Person:0x000055dfc1a92238 @person_id="1", @person_name="Jaskaran", ... 
3.0.0 :013 > person2 = Person.new("2","Rohit","22")
ID is: 2
Name is: Rohit
Age is: 22
 => #<Person:0x000055dfc1fb43b0 @person_id="2", @person_name="Rohit", @pe... 
3.0.0 :014 > class Customer
3.0.0 :015 >   @@no_of_customers=3
3.0.0 :016 >   def initialize(id,name,address)
3.0.0 :017 >     @Customer_id=id
3.0.0 :018 >     @Customer_name=name
3.0.0 :019 >     @Customer_address=address
3.0.0 :020 >     puts "ID is: #@Customer_id"
3.0.0 :022 >     puts "Address is: #@Customer_address"
3.0.0 :023 >     puts "\n"
3.0.0 :024 >   end
3.0.0 :025 > end
 => :initialize 
I
 => #<Customer:0x000055dfc1fe6400 @Customer_id="1", @Customer_name="Jask... 
ID is: 1
Name is: Jaskaran
Address is: Chandigarh

 => #<Customer:0x000055dfc1e13cb8 @Customer_id="2", @Customer_name="Ank...
ID is: 2
Name is: Ankit
Address is: Ambala
 
 => #<Customer:0x000055dfc1ffff40 @Customer_id="3", @Customer_name="Roh... 
3.0.0 :029 > Customer3 = Customer.new("3","Rohit","Mohali")
ID is: 3
Name is: Rohit
Address is: Mohali



#Four type of variables in Ruby

1.Global Variable - Starts with $ sign.Global Variable has global scope and accessible from anywhere in the program.
$global_variable=10
class Class1
    def print_global
        puts "Global variable in Class1 is #$global_variable"
    end
end
class Class2
    def print_global
        puts "Global variable in Class2 is #$global_variable"

    end
end

class1obj = Class1.new
class1obj.print_global
class2obj = Class2.new
class2obj.print_global


[Running] ruby "/home/itsacheckmate/Practise/test.rb"
Global variable in Class1 is 10
Global variable in Class2 is 10

2.Instance Variables-It begins with @.its content is restricted to whatever the object itself refers to. Two separate objects, even though they belong to the same class, are allowed to have different values for their instance variables.

class Customer1
    def initialize(id,name,addr)
        @cust_id=id
        @cust_name=name
        @cust_addr=addr
    
        puts "Customer id #@cust_id"
        puts "Customer name #@cust_name"
        puts "Customer address #@cust_addr"
    end
end

cust1=Customer1.new("1","John","Australia")
cust2=Customer1.new("2","Ron","USA")

[Running] ruby "/home/itsacheckmate/Practise/test.rb"
Customer id 1
Customer name John
Customer address Australia
Customer id 2
Customer name Ron
Customer address USA

3.Class Variables - It begins with @@. A class variable belongs to the class and it is a characteristic of a class. They need to be initialized before use.
class Customer2

    @@no_of_customers=0
    
    def initialize(id,name,addr)
        @cust_id=id
        @cust_name=name
        @cust_addr=addr
    end

    def display_details()
        puts "Customer id #@cust_id"
        puts "Customer name #@cust_name"
        puts "Customer address #@cust_addr"
    end

    def total_no_customers()

        @@no_of_customers +=1
        puts "Total number of customers: #@@no_of_customers"
    end
end

cust1 = Customer2.new("1","Virat","Delhi")
cust2 = Customer2.new("2","Paul","Mysore")

cust1.display_details()
cust1.total_no_customers()
cust2.display_details()
cust2.total_no_customers()


[Running] ruby "/home/itsacheckmate/Practise/test.rb"
Customer id 1
Customer name Virat
Customer address Delhi
Total number of customers: 1
Customer id 2
Customer name Paul
Customer address Mysore
Total number of customers: 2

4.Local Variables: A local variable name always starts with a lowercase letter(a-z) or underscore (_). 
eg 3.0.0 :035 > _age=19
 => 19 
3.0.0 :037"> name="jaskaran"
 => "jaskaran" 
 
 
5. Ruby Constants
Constants begin with UpperCase Letter
If they are defined withing class then they can be accessed within
that module only.
And if constants are defined outside class or module then it is treated as 
globally accessable
Refrencing an uninitialized constants will produce an error


 #Variables in ruby
 class Example 
    VAR1=100
    VAR2=200
    def show
        puts "value of first constant #{VAR1}"
        puts "valye of second constant #{VAR2}"
    end
end


obj=Example.new()
obj.show


[Running] ruby "/home/itsacheckmate/Practise/test.rb"
value of first constant 100
valye of second constant 200

#Operators in Ruby
1.Addition+
a=19
b=4
puts a+b
[Running] ruby "/home/itsacheckmate/Practise/test.rb"
23

2.Subtraction - Subtracts right hand operand from left hand operand.
a=20
b=5
puts a-b
[Running] ruby "/home/itsacheckmate/Practise/test.rb"
15

3.Multiplication *
a=20
b=5
puts a*b
[Running] ruby "/home/itsacheckmate/Practise/test.rb"
100

4.Divsion /
a=20
b=5
puts a/b
[Running] ruby "/home/itsacheckmate/Practise/test.rb"
4

5.Modulus %
a=23
b=6
puts a/b
[Running] ruby "/home/itsacheckmate/Practise/test.rb"
3

6.Exponent **
a=3
b=2
puts a**b

[Running] ruby "/home/itsacheckmate/Practise/test.rb"
9

#Comparison Operators
1.==
a=3
b=2
puts a==b

[Running] ruby "/home/itsacheckmate/Practise/test.rb"
false

2.!=
a=3
b=2
puts a!=b
[Running] ruby "/home/itsacheckmate/Practise/test.rb"
true

3.>
a=3
b=2
puts a>b
[Running] ruby "/home/itsacheckmate/Practise/test.rb"
true

4.<
a=3
b=2
puts a<b
[Running] ruby "/home/itsacheckmate/Practise/test.rb"
false

5.<=
a=3
b=5
puts a<=b

[Running] ruby "/home/itsacheckmate/Practise/test.rb"
true

6.>=
a=3
b=5
puts a>=b

[Running] ruby "/home/itsacheckmate/Practise/test.rb"
false

7.<=>
a=5
b=5
puts a<=>b
[Running] ruby "/home/itsacheckmate/Practise/test.rb"
0

8.eql? - checks both value and data type
a=5
b=5.0
puts a.eql?(b)

#Assignment Operators
1.=Assigns value from right side operand to left side operand
a=10
b=20
c=a+b
puts c

[Running] ruby "/home/itsacheckmate/Practise/test.rb"
30

2.+= Add AND assignment operator, 
a=10
c=1
c+=a
puts c
[Running] ruby "/home/itsacheckmate/Practise/test.rb"
11

[Done] exited with code=0 in 0.043 seconds

3.-=Subtract AND assignment operator,
a=10
c=1
c-=a
puts c
[Running] ruby "/home/itsacheckmate/Practise/test.rb"
-9

4.*=Multiply AND assignment operator
a=10
c=2
c*=a
puts c
[Running] ruby "/home/itsacheckmate/Practise/test.rb"
20

5./= Divide AND assignment operator
a=10
c=20
c/=a
puts c
[Running] ruby "/home/itsacheckmate/Practise/test.rb"
2

6.%= Modulus AND assignment operator
a=6
c=20
c%=a
puts c

[Running] ruby "/home/itsacheckmate/Practise/test.rb"
2

7.*= Exponent AND assignment operator
a=3
c=2
c**=a
puts c
[Running] ruby "/home/itsacheckmate/Practise/test.rb"
8

#Ruby Logical Operators

1.and operator- if both the operands are true, then the condition becomes true.
a=true
b=true

puts (a and b)

[Running] ruby "/home/itsacheckmate/Practise/test.rb"
true

2.or operator - . If any of the two operands are true, then the condition becomes true.
a=true
b=false

puts (a or b)
[Running] ruby "/home/itsacheckmate/Practise/test.rb"
true

3.Called Logical NOT Operator. Use to reverses the logical state of its operand. 
a=false
b=true

puts !(a && b)


#Ruby Ternary Operator
?:  Conditonal expression
If Condition is true ? Then value X : Otherwise value Y
score=50
result=score>40?'Pass':'Fail'
puts result
[Running] ruby "/home/itsacheckmate/Practise/test.rb"
Pass


Ruby Range Operator
It is used to create a range of successive values - 
consisting of a start value, an end value, and a 
range of values in between.

The two-dot form creates an inclusive range, 
while the three-dot form creates a range that 
excludes the specified high value.
so 1..10 is 1,2,3,4,5,6,7,8,9,10
and 1...10 is 1,2,3,4,5,6,7,8,9

$, =", "
range_op=(7 ..10).to_a
puts "#{range_op}"

range_op1=(7 ... 10).to_a
puts "#{range_op1}"
Running] ruby "/home/itsacheckmate/Practise/test.rb"
[7, 8, 9, 10]
[7, 8, 9]


#Ruby if,else-if etc 
if(condition)  
    # code if the condition is true 
else  
 # code if the condition is false  
end  

3.0.0 :051 > a=15
 => 15 
3.0.0 :052 > if a>=18
3.0.0 :053 >   puts "you are eligible to vote"
3.0.0 :054 > else
3.0.0 :055 >   puts "not eligible to vote"
3.0.0 :056 > end
not eligible to vote
 => nil 



=>if...else Statement
Syntax

if conditional [then]
   code...
[elsif conditional [then]
   code...]...
[else
   code...]
end

1.x=1
if x>2
    puts "x is greater than 2"
elsif x<=2 and x!=0
    puts "x is 1"
else
    puts "cant guess the number"
end

[Running] ruby "/home/itsacheckmate/Practise/test.rb"
x is 1

2.a=88
if a<50
    puts "student is fail"
elsif a>=50 && a<=60
    puts "Student gets D grade"
    elsif a>=60 && a<=70
        puts "student gets c grade"
        elsif a>=70 && a<=80
            puts "student gets b grade"
        elsif a>=80 && a<=90
        puts "student gets a grade"
        elsif a>=90 && a<=100
            puts "student gets a+ grade"
end

[Running] ruby "/home/itsacheckmate/Practise/test.rb"
student gets a grade


=>Ruby unless Statement
Syntax
unless conditional [then]
   code
[else
   code ]
end

3.0.0 :045 > x=1
 => 1 
3.0.0 :046 > unless x>=2
3.0.0 :047 >   puts "x is less than 2"
3.0.0 :048 > else
3.0.0 :049 >   puts "x is greater than 2"
3.0.0 :050 > end
x is less than 2
 => nil


=>Ruby case Statement
Syntax

case expression
[when expression [, expression ...] [then]
   code ]...
[else
   code ]
end

$age =13
case $age
when 0 .. 2
    puts "baby"
when 3 .. 6
    puts "little child"
when 7 .. 12
    puts "child"
when 13 .. 18
    puts "youth"
else
    puts "adult"
end

[Running] ruby "/home/itsacheckmate/Practise/test.rb"
youth

#Ruby while Statement
Syntax

while conditional [do]
   code
end

$i=0
$num =10

while $i<$num do
    puts("Inside the loop i=#$i")
    $i += 1
end
[Running] ruby "/home/itsacheckmate/Practise/test.rb"
Inside the loop i=0
Inside the loop i=1
Inside the loop i=2
Inside the loop i=3
Inside the loop i=4
Inside the loop i=5
Inside the loop i=6
Inside the loop i=7
Inside the loop i=8
Inside the loop i=9

=>Ruby until Statement

until conditional [do]
   code
end

$i =0 
$num = 5
until $i > $num do
    puts("Inside the loop i = #$i")
    $i += 1;
end

*Ruby until modifier
Syntax

code until conditional

OR

begin
   code
end until conditional

$i = 0
$num = 5
begin
    
puts("Inside the loop i = #$i")
$i += 1
end until $i > $num

[Running] ruby "/home/itsacheckmate/Practise/test.rb"
Inside the loop i = 0
Inside the loop i = 1
Inside the loop i = 2
Inside the loop i = 3
Inside the loop i = 4
Inside the loop i = 5

=>Ruby for Statement
Syntax

for variable [, variable ...] in expression [do]
   code
end

for i in 0 .. 5
    puts "Value of local var is #{i}"
end
[Running] ruby "/home/itsacheckmate/Practise/test.rb"
Value of local var is 0
Value of local var is 1
Value of local var is 2
Value of local var is 3
Value of local var is 4
Value of local var is 5


arr = ["mumbai","chandigarh","faridabad"]
for i in arr do
    puts i
end
[Running] ruby "/home/itsacheckmate/Practise/test.rb"
mumbai
chandigarh
faridabad

=>Ruby break Statement
Syntax

break

for i in 0 .. 5
    if i>2 then
        break
    end
    puts "value is #{i}"
end
[Running] ruby "/home/itsacheckmate/Practise/test.rb"
value is 0
value is 1
value is 2

=>Ruby next Statement
Syntax

next

for i in 0 ..5
    if i<2 then 
        next
    end
    puts "value of i is #{i}"
end
[Running] ruby "/home/itsacheckmate/Practise/test.rb"
value of i is 2
value of i is 3
value of i is 4
value of i is 5

=>Ruby redo Statement
Syntax

redo

for i in 0..5
    if i < 2 then
        puts "value of local #{i}"
        redo
    end
end
[Done] exited with code=0 in 0.039 seconds

value of local 0
value of local 0
value of local 0
value of local 0
-------------
infinite loop


=>Ruby redo Statement
Syntax

redo

for i in 0 .. 5
    if i<2 then
        puts "value of local is #{i}"
        redo
    end
end

value of local 0
value of local 0
value of local 0
value of local 0
-------------
infinite loop


#METHODS IN RUBY
Ruby methods are used to bundle one or more repeatable statements into a single unit.
Method names should begin with a lowercase letter.

Syntax:

def method_name
# Statement 1
# Statement 2
.
.
end

3.0.0 :019 > def method1
3.0.0 :020 >   puts "this is a method"
3.0.0 :021 > end
 => :method1 
3.0.0 :022 > method1
this is a method
 => nil 

=>Passing parameters to methods: In Ruby, parameter passing is similar to other programming language’s parameter passing i.e simply write the parameters in the brackets ().
Syntax:

def method_name(var1, var2, var3)
# Statement 1
# Statement 2
.
.
end

def car (var1="color",var2="brand")
    puts "The color of the car is #{var1}"
    puts "The brand of the car is #{var2}"
end
car "Blue", "Mercedes"
puts ""

puts "calling the method without passing the parameters"
puts ""

car
Running] ruby "/home/itsacheckmate/Practise/test.rb"
The color of the car is Blue
The brand of the car is Mercedes

calling the method without passing the parameters

The color of the car is color
The brand of the car is brand

[Done] exited with code=0 in 0.047 seconds

=>Variable Number of Parameters: Ruby allows the programmer to define a method that can take the variable number of arguments.
def animals (*var)
    puts "Number of paramters is: #{var.length}"
    for i in 0...var.length
        puts "Parameters are: #{var[i]}"
    end
end

animals "dog","cat"
animals "Tiger"

[Running] ruby "/home/itsacheckmate/Practise/test.rb"
Number of paramters is: 2
Parameters are: dog
Parameters are: cat
Number of paramters is: 1
Parameters are: Tiger

[Done] exited with code=0 in 0.038 seconds

def para(*var)
    puts "number of parameters is: #{var.length}"

    for i in 0...var.length
        puts "Parameters are: #{var[i]}"
    end
end

para "Hi","Hello"
para "hihihi"
para "hello there","wassup","greetings"
[Running] ruby "/home/itsacheckmate/Practise/test.rb"
number of parameters is: 2
Parameters are: Hi
Parameters are: Hello
number of parameters is: 1
Parameters are: hihihi
number of parameters is: 3
Parameters are: hello there
Parameters are: wassup
Parameters are: greetings

[Done] exited with code=0 in 0.053 seconds

=>Return statement in Methods: Return statement used to returns one or more values. By default, a method always returns the last statement that was evaluated in the body of the method.
def num
    a=10
    b=39
    sum=a+b
        return sum
      
    end
puts "the result is: #{num}"
[Running] ruby "/home/itsacheckmate/Practise/test.rb"
the result is: 49

[Done] exited with code=0 in 0.044 seconds

=>Class Methods==>
  When a method is defined outside of the class definition, 
  the method is marked as private by default. On the other hand,
   the methods defined in the class definition are marked as 
   public by default. The default visibility and the private 
   mark of the methods can be changed by public or private of 
   the Module.

 to access a method of a class,  first 
need to instantiate the class. Then, using the object,  
can access any member of the class.

Ruby gives you a way to access a method without 
instantiating a class.
3.0.0 :009 > class Accounts
3.0.0 :010 >   def reading_charge
3.0.0 :011 >   end
3.0.0 :012 >   def Accounts.return_date
3.0.0 :013 >   end
3.0.0 :014 > end
 => :return_date 
3.0.0 :015 > Accounts.return_date
 => nil 
 To access this method, no need to create objects of the 
class Accounts

=>Ruby Alias Statement
This gives alias to methods or global variables
Aliases cannot be defined within the method body. 
The alias of the method keeps the current definition 
of the method, even when methods are overridden.

Syntax
alias method-name method-name
alias global-variable-name global-variable-name

3.0.0 :026 > alias sam geeks
 => nil 
3.0.0 :027 > sam "hello",1,324
Number of parameters is: 3
Parameters are: hello
Parameters are: 1
Parameters are: 324
 => 0...3 

3.0.0 :017 > class Microwave
3.0.0 :019 >     puts "The microwave is on"
3.0.0 :020 >   end
3.0.0 :021 >   alias :start :on
3.0.0 :022 > end
 => nil 
3.0.0 :023 > m=Microwave.new
 => #<Microwave:0x0000556fccde46a8> 
3.0.0 :024 > m.start
The microwave is on
 => nil 

=>Ruby Undef Statement
This cancels the method definition. An undef cannot appear in the method body.Syntax

Syntax:
undef method-name
3.0.0 :028 > undef sam
 => nil 
3.0.0 :029"> sam "hello"
Traceback (most recent call last):
        4: from /home/itsacheckmate/.rvm/rubies/ruby-3.0.0/bin/irb:23:in `<main>'
        3: from /home/itsacheckmate/.rvm/rubies/ruby-3.0.0/bin/irb:23:in `load'
        2: from /home/itsacheckmate/.rvm/rubies/ruby-3.0.0/lib/ruby/gems/3.0.0/gems/irb-1.3.0/exe/irb:11:in `<top (required)>'
        1: from (irb):29:in `<main>'
NoMethodError (undefined method `sam' for main:Object)
3.0.0 :030 > sample "windows","32","m","bca"

=> Ruby Blocks

A block is the same thing as a method, but it does not belong to an object.
A block consists of chunks of code.You assign a name to a block.
The code in the block is always enclosed within braces ({}).
We invoke a block by using the yield statement.
Syntax

block_name {
   statement1
   statement2
   ..........
}
3.0.0 :001 > def test
3.0.0 :002 >   puts "You are in the method"
3.0.0 :003 >   yield
3.0.0 :004 >   puts "You are again back to the method"
3.0.0 :005 >   yield
3.0.0 :006 > end
 => :test 
3.0.0 :007 > test {puts "You are in the block"}
You are in the method
You are in the block
You are again back to the method
You are in the block
 => nil 

The yield statement is written followed by parameters.
  You can even pass more than one parameter. In the block, 
  you place a variable between two vertical lines (||) to 
  accept the parameters. Therefore, in the preceding code,
   the yield 5 statement passes the value 5 as a parameter 
   to the test block.
   
   3.0.0 :009 > def test
3.0.0 :010 >   yield 5
3.0.0 :011 >   puts "you are in the method test"
3.0.0 :012 >   yield 100
3.0.0 :013 > end
 => :test 
3.0.0 :014 > test {|i| puts "You are the block #{i}"}
You are the block 5
you are in the method test
You are the block 100
 => nil 
 
 if you want to pass more than one parameters, then the yield statement becomes - 
 yield a, b==>
 3.0.0 :032 > def test
3.0.0 :033 >   yield 70,100
3.0.0 :034 >   puts "You are in the method test"
3.0.0 :035 >   yield 1000
3.0.0 :036 > end
 => :test 
3.0.0 :037 > test {|i,j| puts "You are in the block #{i} and #{j}"}
You are in the block 70 and 100
You are in the method test
You are in the block 1000 and 
 => nil 

But if the last argument of a method is preceded by &,
      then you can pass a block to this method and this 
      block will be assigned to the last parameter. In case
          both * and & are present in the argument list, & 
          should come later.
          
          3.0.0 :042 > def test(&block)
3.0.0 :043 >   block.call
3.0.0 :044 > end
 => :test 
Hello World!
 => nil 

#Module Ruby
A Module is a collection of methods, constants, and class variables.
You cannot inherit modules or you can’t create a subclass of a module.
Objects cannot be created from a module.
Modules are used as namespaces and as mixins.
All the classes are modules, but all the modules are not classes.
The name of a module must start with a capital letter.

Syntax:

module Module_name

   # statements to be executed

end

3.0.0 :069 > module Trig
3.0.0 :070 >   PI = 3.141592654
3.0.0 :071 >   def Trig.sin(x)
3.0.0 :072 >     # ..
3.0.0 :073 >   end
3.0.0 :074 >   def Trig.cos(x)
3.0.0 :075 >     # ..
3.0.0 :076 >   end
3.0.0 :077 > end
 => :cos 

module Gfg
    C=10;
    def Gfg.portal
        puts "Welcome!"
    end
    
    def Gfg.tutorial
        puts "Ruby tutorial"
    end
    def Gfg.topic
        puts "Topic - Module"
    end
end

puts Gfg::C

Gfg.portal
Gfg.tutorial
Gfg.topic
[Running] ruby "/home/itsacheckmate/Practise/test.rb"
10
Welcome!
Ruby tutorial
Topic - Module

include statement
embed a module in a class. To embed a module in a class,
 you use the include statement in the class
applying method

module=>
module Week
    FIRST_DAY = "Sunday"
    def Week.weeks_in_month
        puts "You have four weeks in a month"
    end
    def Week.weeks_in_year
        puts "You have 52 weeks in a year"
    end
end


code-->
class Decade
    include Week
    no_of_yrs=10
    def no_of_months
        puts Week::FIRST_DAY
        number=10*12
        puts number
    end
end
d1=Decade.new
puts Week::FIRST_DAY
Week.weeks_in_month
Week.weeks_in_year
d1.no_of_months

[Running] ruby "/home/itsacheckmate/Practise/test.rb"
Sunday
You have four weeks in a month
You have 52 weeks in a year
Sunday
120

[Done] exited with code=0 in 0.038 seconds

#Mixins in Ruby
Ruby does not support multiple inheritance.Mixins give you a wonderfully controlled way of adding functionality to classes.
to apply multiple inheritence in ruby mixins facility is provided

module A
    def a1
        puts "Method a1 of module A"
    end
    def a2
        puts "Method a2 of module A"
    end
end
module B                           
    def b1 
        puts "Method b1 of module B"
    end
    def b2
        puts "Method b2 of module B"
    end
end

class Sample
    include A
    include B
    def s1

    end
end
samp=Sample.new
samp.a1
samp.a2
samp.b1
samp.b2
samp.s1


[Running] ruby "/home/itsacheckmate/Practise/tempCodeRunnerFile.rb"
Method a1 of module A
Method a2 of module A
Method b1 of module B
Method b2 of module B

[Done] exited with code=0 in 0.047 seconds

The class sample can access all four methods a1,a2,b1 and b2 therefore class Sample inherits
from both the modules.

samp.s1


Ruby Iterators

Iterators are nothing but methods supported by collections. 
Objects that store a group of data members are called collections.
 In Ruby, arrays and hashes can be termed collections.

Iterators return all the elements of a collection, 
one after the other.

two common iterators are, each and collect

Ruby each Iterator
The each iterator returns all the elements of an array or a
 hash.

 Executes code for each element in collection. 
 Here, collection could be an array or a ruby hash.

Syntax
collection.each do |variable|
   code
end

3.0.0 :134 > ary = [1,2,3,4,5]
 => [1, 2, 3, 4, 5] 
3.0.0 :135 > ary.each do |i|
3.0.0 :136 >    puts i
3.0.0 :137 > end
1
2
3
4
5
 => [1, 2, 3, 4, 5] 


 Ruby collect Iterator
The collect iterator returns all the elements of a collection.
Syntax
collection = collection.collect

The collect method need not always be associated with a block.
 The collect method returns the entire collection,
 regardless of whether it is an array or a hash.
 
 #Iterators in Ruby
Iterators” is the object-oriented concept in Ruby.
In more simple words, iterators are the methods which are supported by collections(Arrays, Hashes etc.). 
Collections are the objects which store a group of data members.
Ruby iterators return all the elements of a collection one after another.

There are many iterators in Ruby as follows: 
1.Each Iterator
2.Collect Iterator
3.Times Iterator
4.Upto Iterator
5.Downto Iterator
6.Step Iterator
7.Each_Line Iterator


1.Each Iterator: This iterator returns all the elements of an array or a hash. Each iterator returns each value one by one. 
Syntax:
3.0.0 :001 > (0..9).each do |i|
3.0.0 :002 >   puts i
3.0.0 :003 > end
0
1
2
3
4
5
6
7
8
9
 => 0..9 
3.0.0 :004 > a = ['J', 'A', 'S', 'K', 'A', 'R', 'A', 'N']
 => ["J", "A", "S", "K", "A", "R", "A", "N"] 
3.0.0 :005 > puts "\n"

 => nil 
3.0.0 :006 > a.each do|arr|
3.0.0 :007 >   puts arr
3.0.0 :008 > end
J
A
S
K
A
R
A
N
 => ["J", "A", "S", "K", "A", "R", "A", "N"] 
 
 2.    Collect Iterator: This iterator returns all the elements of a collection. The collect iterator returns an entire collection, regardless of whether it is an array or hash.
    Syntax: 
    
Collection = collection.collect

3.0.0 :001 > a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
 => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 
3.0.0 :002 > b = a.collect{ |y| (5*y) }
 => [5, 10, 15, 20, 25, 30, 35, 40, 45, 50] 
3.0.0 :003 > puts b
5
10
15
20
25
30
35
40
45
50
 => nil 

3.Times Iterator: In this iterator, a loop is implanted with the specific number of time. The loop is initially started from zero and runs until the one less than the specified number.
    Syntax:
     

t.times do |variable_name|

# code to be execute

end

3.0.0 :004 > 7.times do |i|
3.0.0 :005 >   puts i
3.0.0 :006 > end
0
1
2
3
4
5
6
 => 7 
 
 4.Upto Iterator: This iterator follows top to bottom approach. It includes both the top and bottom variable in the iteration.
     Syntax: 
     

top.upto(bottom) do |variable_name|

# code to execute

end

3.0.0 :007 > 4.upto(7) do |n|
3.0.0 :008 >   puts n
3.0.0 :009 > end
4
5
6
7
 => 4 
3.0.0 :010 > 7.upto(4) do |n|
3.0.0 :011 >   puts n
3.0.0 :012 > end
 => 7 


5.    Downto Iterator: This iterator follows bottom to top approach. It includes both the top and bottom variable in the iteration. 
    Syntax: 
     

top.downto(bottom) do |variable_name|

# code to execute

end

3.0.0 :013 > 10.downto(5) do |n|
3.0.0 :014 >   puts n
3.0.0 :015 > end
10
9
8
7
6
5
 => 10 
3.0.0 :016 > 4.downto(7) do |n|
3.0.0 :017 >   puts n
3.0.0 :018 > end
 => 4 

    6.Step Iterator: Ruby step iterator is used to iterate where the user has to skip a specified range. 
    Syntax: 
     

Collection.step(rng) do |variable_name|

# code to be executed

end 

3.0.0 :019 > (0..100).step(20) do|i|
3.0.0 :020 >   puts i
3.0.0 :021 > end
0
20
40
60
80
100
 => 0..100
 
 7.Each_line Iterator: Ruby each_line iterator is used to iterate over a new line in the string. 
    Syntax:
     

string.each_line do |variable_name|

# code to be executed

end

3.0.0 :025 > "Today\nis\na\nrainyday".each_line do|i|
3.0.0 :026 >   puts i
3.0.0 :027 > end
Today
is
a
rainyday
 => "Today\nis\na\nrainyday" 



