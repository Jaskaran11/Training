Ruby is a perfect Object Oriented Programming Language. The features of the object-oriented programming language include −
    Data Encapsulation
    Data Abstraction
    Polymorphism
    Inheritance


#check ruby version
itsacheckmate@itscheckmate:~$ ruby -v
ruby 3.0.0p0 (2020-12-25 revision 95aff21468) [x86_64-linux]

#Basic code practise

itsacheckmate@itscheckmate:~$ irb
3.0.0 :001 > 



#3.0.0 :024 > puts "hello world"
hello world
 => nil 

# multiple line
3.0.0 :001"> puts <<EOF
3.0.0 :002"> this is the first line
3.0.0 :003"> this is the second line
3.0.0 :004"> EOF
3.0.0 :005"> 
this is the first line
this is the second line
 => nil
3.0.0 :007'> print <<'EOC'
3.0.0 :008'> echo hi there
3.0.0 :010 > EOC
echo hi there
 => nil 
 
#In Ruby, nil is a special value that denotes the absence of any value. Nil is an object of NilClass. nil is Ruby's way of referring to nothing or void. 
 
 
 
 Ruby Begin ==> Declares code to be called before the program is run
 Ruby END Statement==>Declares to be called at the end of the program
 
#puts "This line will run in between the code"

END{
    puts "This line will run after "
}
BEGIN{
    puts "This line will run first."
}

Output - [Running] ruby "/home/itsacheckmate/Practise/test.rb"
This line will run first.
This line will run in between the code
This line will run after 

3.0.0 :001'> print <<'EOC'
3.0.0 :002'> echo hi there
3.0.0 :003'> echo lo there
3.0.0 :004'> EOC
echo hi there
echo lo there
 => nil 


print <<"foo", <<"bar"  
	I said foo.
foo
	I said bar.
bar

#Comments in ruby
3.0.0 :006 > #this is a comment
 => nil 
3.0.0 :007 > name = "Jaskaran" #This is a comment
 => "Jaskaran" 
 
 #another way of comment
 =begin
    this is a comment
    this is also a comment
    this is a comment too
rescue => exception
    
end


#Class 
A class is a blueprint from which objects are created. The object is also called as an instance of a class.

3.0.0 :009 > class Vehicle
3.0.0 :010 >   def initialize(id,color,name)
3.0.0 :018 >   end
3.0.0 :019 > end
 => :initialize 
3.0.0 :020 > xveh = Vehicle. new("1","Red","ABC")
Id is : 1
Color is: Red
Name is: ABC

 => #<Vehicle:0x000055dacc6d21d8 @veh_id="1", @veh_color="Red", @veh_name... 
3.0.0 :021 > yveh = Vehicle. new("2","Black","XYZ")
Id is : 2
Color is: Black
Name is: XYZ


itsacheckmate@itscheckmate:~$ irb
3.0.0 :001 > class Person
3.0.0 :002 >   def initialize(id,name,age)
3.0.0 :003 >     @person_id=id
Age is: 23
 => #<Person:0x000055dfc1a92238 @person_id="1", @person_name="Jaskaran", ... 
3.0.0 :013 > person2 = Person.new("2","Rohit","22")
ID is: 2
Name is: Rohit
Age is: 22
 => #<Person:0x000055dfc1fb43b0 @person_id="2", @person_name="Rohit", @pe... 
3.0.0 :014 > class Customer
3.0.0 :015 >   @@no_of_customers=3
3.0.0 :016 >   def initialize(id,name,address)
3.0.0 :017 >     @Customer_id=id
3.0.0 :018 >     @Customer_name=name
3.0.0 :019 >     @Customer_address=address
3.0.0 :020 >     puts "ID is: #@Customer_id"
3.0.0 :022 >     puts "Address is: #@Customer_address"
3.0.0 :023 >     puts "\n"
3.0.0 :024 >   end
3.0.0 :025 > end
 => :initialize 
I
 => #<Customer:0x000055dfc1fe6400 @Customer_id="1", @Customer_name="Jask... 
ID is: 1
Name is: Jaskaran
Address is: Chandigarh

 => #<Customer:0x000055dfc1e13cb8 @Customer_id="2", @Customer_name="Ank...
ID is: 2
Name is: Ankit
Address is: Ambala
 
 => #<Customer:0x000055dfc1ffff40 @Customer_id="3", @Customer_name="Roh... 
3.0.0 :029 > Customer3 = Customer.new("3","Rohit","Mohali")
ID is: 3
Name is: Rohit
Address is: Mohali



#Four type of variables in Ruby

1.Global Variable - Starts with $ sign.Global Variable has global scope and accessible from anywhere in the program.
$global_variable=10
class Class1
    def print_global
        puts "Global variable in Class1 is #$global_variable"
    end
end
class Class2
    def print_global
        puts "Global variable in Class2 is #$global_variable"

    end
end

class1obj = Class1.new
class1obj.print_global
class2obj = Class2.new
class2obj.print_global


[Running] ruby "/home/itsacheckmate/Practise/test.rb"
Global variable in Class1 is 10
Global variable in Class2 is 10

2.Instance Variables-It begins with @.its content is restricted to whatever the object itself refers to. Two separate objects, even though they belong to the same class, are allowed to have different values for their instance variables.

class Customer1
    def initialize(id,name,addr)
        @cust_id=id
        @cust_name=name
        @cust_addr=addr
    
        puts "Customer id #@cust_id"
        puts "Customer name #@cust_name"
        puts "Customer address #@cust_addr"
    end
end

cust1=Customer1.new("1","John","Australia")
cust2=Customer1.new("2","Ron","USA")

[Running] ruby "/home/itsacheckmate/Practise/test.rb"
Customer id 1
Customer name John
Customer address Australia
Customer id 2
Customer name Ron
Customer address USA

3.Class Variables - It begins with @@. A class variable belongs to the class and it is a characteristic of a class. They need to be initialized before use.
class Customer2

    @@no_of_customers=0
    
    def initialize(id,name,addr)
        @cust_id=id
        @cust_name=name
        @cust_addr=addr
    end

    def display_details()
        puts "Customer id #@cust_id"
        puts "Customer name #@cust_name"
        puts "Customer address #@cust_addr"
    end

    def total_no_customers()

        @@no_of_customers +=1
        puts "Total number of customers: #@@no_of_customers"
    end
end

cust1 = Customer2.new("1","Virat","Delhi")
cust2 = Customer2.new("2","Paul","Mysore")

cust1.display_details()
cust1.total_no_customers()
cust2.display_details()
cust2.total_no_customers()


[Running] ruby "/home/itsacheckmate/Practise/test.rb"
Customer id 1
Customer name Virat
Customer address Delhi
Total number of customers: 1
Customer id 2
Customer name Paul
Customer address Mysore
Total number of customers: 2

4.Local Variables: A local variable name always starts with a lowercase letter(a-z) or underscore (_). 
eg 3.0.0 :035 > _age=19
 => 19 
3.0.0 :037"> name="jaskaran"
 => "jaskaran" 
 
 
5. Ruby Constants
Constants begin with UpperCase Letter
If they are defined withing class then they can be accessed within
that module only.
And if constants are defined outside class or module then it is treated as 
globally accessable
Refrencing an uninitialized constants will produce an error


 #Variables in ruby
 class Example 
    VAR1=100
    VAR2=200
    def show
        puts "value of first constant #{VAR1}"
        puts "valye of second constant #{VAR2}"
    end
end


obj=Example.new()
obj.show


[Running] ruby "/home/itsacheckmate/Practise/test.rb"
value of first constant 100
valye of second constant 200

#Operators in Ruby
1.Addition+
a=19
b=4
puts a+b
[Running] ruby "/home/itsacheckmate/Practise/test.rb"
23

2.Subtraction - Subtracts right hand operand from left hand operand.
a=20
b=5
puts a-b
[Running] ruby "/home/itsacheckmate/Practise/test.rb"
15

3.Multiplication *
a=20
b=5
puts a*b
[Running] ruby "/home/itsacheckmate/Practise/test.rb"
100

4.Divsion /
a=20
b=5
puts a/b
[Running] ruby "/home/itsacheckmate/Practise/test.rb"
4

5.Modulus %
a=23
b=6
puts a/b
[Running] ruby "/home/itsacheckmate/Practise/test.rb"
3

6.Exponent **
a=3
b=2
puts a**b

[Running] ruby "/home/itsacheckmate/Practise/test.rb"
9

#Comparison Operators
1.==
a=3
b=2
puts a==b

[Running] ruby "/home/itsacheckmate/Practise/test.rb"
false

2.!=
a=3
b=2
puts a!=b
[Running] ruby "/home/itsacheckmate/Practise/test.rb"
true

3.>
a=3
b=2
puts a>b
[Running] ruby "/home/itsacheckmate/Practise/test.rb"
true

4.<
a=3
b=2
puts a<b
[Running] ruby "/home/itsacheckmate/Practise/test.rb"
false

5.<=
a=3
b=5
puts a<=b

[Running] ruby "/home/itsacheckmate/Practise/test.rb"
true

6.>=
a=3
b=5
puts a>=b

[Running] ruby "/home/itsacheckmate/Practise/test.rb"
false

7.<=>
a=5
b=5
puts a<=>b
[Running] ruby "/home/itsacheckmate/Practise/test.rb"
0

8.eql? - checks both value and data type
a=5
b=5.0
puts a.eql?(b)

#Assignment Operators
1.=Assigns value from right side operand to left side operand
a=10
b=20
c=a+b
puts c

[Running] ruby "/home/itsacheckmate/Practise/test.rb"
30

2.+= Add AND assignment operator, 
a=10
c=1
c+=a
puts c
[Running] ruby "/home/itsacheckmate/Practise/test.rb"
11

[Done] exited with code=0 in 0.043 seconds

3.-=Subtract AND assignment operator,
a=10
c=1
c-=a
puts c
[Running] ruby "/home/itsacheckmate/Practise/test.rb"
-9

4.*=Multiply AND assignment operator
a=10
c=2
c*=a
puts c
[Running] ruby "/home/itsacheckmate/Practise/test.rb"
20

5./= Divide AND assignment operator
a=10
c=20
c/=a
puts c
[Running] ruby "/home/itsacheckmate/Practise/test.rb"
2

6.%= Modulus AND assignment operator
a=6
c=20
c%=a
puts c

[Running] ruby "/home/itsacheckmate/Practise/test.rb"
2

7.*= Exponent AND assignment operator
a=3
c=2
c**=a
puts c
[Running] ruby "/home/itsacheckmate/Practise/test.rb"
8

#Ruby Logical Operators

1.and operator- if both the operands are true, then the condition becomes true.
a=true
b=true

puts (a and b)

[Running] ruby "/home/itsacheckmate/Practise/test.rb"
true

2.or operator - . If any of the two operands are true, then the condition becomes true.
a=true
b=false

puts (a or b)
[Running] ruby "/home/itsacheckmate/Practise/test.rb"
true

3.Called Logical NOT Operator. Use to reverses the logical state of its operand. 
a=false
b=true

puts !(a && b)


#Ruby Ternary Operator
?:  Conditonal expression
If Condition is true ? Then value X : Otherwise value Y
score=50
result=score>40?'Pass':'Fail'
puts result
[Running] ruby "/home/itsacheckmate/Practise/test.rb"
Pass


Ruby Range Operator
It is used to create a range of successive values - 
consisting of a start value, an end value, and a 
range of values in between.

The two-dot form creates an inclusive range, 
while the three-dot form creates a range that 
excludes the specified high value.
so 1..10 is 1,2,3,4,5,6,7,8,9,10
and 1...10 is 1,2,3,4,5,6,7,8,9

$, =", "
range_op=(7 ..10).to_a
puts "#{range_op}"

range_op1=(7 ... 10).to_a
puts "#{range_op1}"
Running] ruby "/home/itsacheckmate/Practise/test.rb"
[7, 8, 9, 10]
[7, 8, 9]


#Ruby if,else-if etc 
if(condition)  
    # code if the condition is true 
else  
 # code if the condition is false  
end  

3.0.0 :051 > a=15
 => 15 
3.0.0 :052 > if a>=18
3.0.0 :053 >   puts "you are eligible to vote"
3.0.0 :054 > else
3.0.0 :055 >   puts "not eligible to vote"
3.0.0 :056 > end
not eligible to vote
 => nil 



=>if...else Statement
Syntax

if conditional [then]
   code...
[elsif conditional [then]
   code...]...
[else
   code...]
end

1.x=1
if x>2
    puts "x is greater than 2"
elsif x<=2 and x!=0
    puts "x is 1"
else
    puts "cant guess the number"
end

[Running] ruby "/home/itsacheckmate/Practise/test.rb"
x is 1

2.a=88
if a<50
    puts "student is fail"
elsif a>=50 && a<=60
    puts "Student gets D grade"
    elsif a>=60 && a<=70
        puts "student gets c grade"
        elsif a>=70 && a<=80
            puts "student gets b grade"
        elsif a>=80 && a<=90
        puts "student gets a grade"
        elsif a>=90 && a<=100
            puts "student gets a+ grade"
end

[Running] ruby "/home/itsacheckmate/Practise/test.rb"
student gets a grade


=>Ruby unless Statement
Syntax
unless conditional [then]
   code
[else
   code ]
end

3.0.0 :045 > x=1
 => 1 
3.0.0 :046 > unless x>=2
3.0.0 :047 >   puts "x is less than 2"
3.0.0 :048 > else
3.0.0 :049 >   puts "x is greater than 2"
3.0.0 :050 > end
x is less than 2
 => nil


=>Ruby case Statement
Syntax

case expression
[when expression [, expression ...] [then]
   code ]...
[else
   code ]
end

$age =13
case $age
when 0 .. 2
    puts "baby"
when 3 .. 6
    puts "little child"
when 7 .. 12
    puts "child"
when 13 .. 18
    puts "youth"
else
    puts "adult"
end

[Running] ruby "/home/itsacheckmate/Practise/test.rb"
youth

#Ruby while Statement
Syntax

while conditional [do]
   code
end

$i=0
$num =10

while $i<$num do
    puts("Inside the loop i=#$i")
    $i += 1
end
[Running] ruby "/home/itsacheckmate/Practise/test.rb"
Inside the loop i=0
Inside the loop i=1
Inside the loop i=2
Inside the loop i=3
Inside the loop i=4
Inside the loop i=5
Inside the loop i=6
Inside the loop i=7
Inside the loop i=8
Inside the loop i=9

=>Ruby until Statement

until conditional [do]
   code
end

$i =0 
$num = 5
until $i > $num do
    puts("Inside the loop i = #$i")
    $i += 1;
end

*Ruby until modifier
Syntax

code until conditional

OR

begin
   code
end until conditional

$i = 0
$num = 5
begin
    
puts("Inside the loop i = #$i")
$i += 1
end until $i > $num

[Running] ruby "/home/itsacheckmate/Practise/test.rb"
Inside the loop i = 0
Inside the loop i = 1
Inside the loop i = 2
Inside the loop i = 3
Inside the loop i = 4
Inside the loop i = 5

=>Ruby for Statement
Syntax

for variable [, variable ...] in expression [do]
   code
end

for i in 0 .. 5
    puts "Value of local var is #{i}"
end
[Running] ruby "/home/itsacheckmate/Practise/test.rb"
Value of local var is 0
Value of local var is 1
Value of local var is 2
Value of local var is 3
Value of local var is 4
Value of local var is 5


arr = ["mumbai","chandigarh","faridabad"]
for i in arr do
    puts i
end
[Running] ruby "/home/itsacheckmate/Practise/test.rb"
mumbai
chandigarh
faridabad

=>Ruby break Statement
Syntax

break

for i in 0 .. 5
    if i>2 then
        break
    end
    puts "value is #{i}"
end
[Running] ruby "/home/itsacheckmate/Practise/test.rb"
value is 0
value is 1
value is 2

=>Ruby next Statement
Syntax

next

for i in 0 ..5
    if i<2 then 
        next
    end
    puts "value of i is #{i}"
end
[Running] ruby "/home/itsacheckmate/Practise/test.rb"
value of i is 2
value of i is 3
value of i is 4
value of i is 5

=>Ruby redo Statement
Syntax

redo

for i in 0..5
    if i < 2 then
        puts "value of local #{i}"
        redo
    end
end
[Done] exited with code=0 in 0.039 seconds

value of local 0
value of local 0
value of local 0
value of local 0
-------------
infinite loop


=>Ruby redo Statement
Syntax

redo

for i in 0 .. 5
    if i<2 then
        puts "value of local is #{i}"
        redo
    end
end

value of local 0
value of local 0
value of local 0
value of local 0
-------------
infinite loop


#METHODS IN RUBY
Ruby methods are used to bundle one or more repeatable statements into a single unit.
Method names should begin with a lowercase letter.

Syntax:

def method_name
# Statement 1
# Statement 2
.
.
end

3.0.0 :019 > def method1
3.0.0 :020 >   puts "this is a method"
3.0.0 :021 > end
 => :method1 
3.0.0 :022 > method1
this is a method
 => nil 

=>Passing parameters to methods: In Ruby, parameter passing is similar to other programming language’s parameter passing i.e simply write the parameters in the brackets ().
Syntax:

def method_name(var1, var2, var3)
# Statement 1
# Statement 2
.
.
end

def car (var1="color",var2="brand")
    puts "The color of the car is #{var1}"
    puts "The brand of the car is #{var2}"
end
car "Blue", "Mercedes"
puts ""

puts "calling the method without passing the parameters"
puts ""

car
Running] ruby "/home/itsacheckmate/Practise/test.rb"
The color of the car is Blue
The brand of the car is Mercedes

calling the method without passing the parameters

The color of the car is color
The brand of the car is brand

[Done] exited with code=0 in 0.047 seconds

=>Variable Number of Parameters: Ruby allows the programmer to define a method that can take the variable number of arguments.
def animals (*var)
    puts "Number of paramters is: #{var.length}"
    for i in 0...var.length
        puts "Parameters are: #{var[i]}"
    end
end

animals "dog","cat"
animals "Tiger"

[Running] ruby "/home/itsacheckmate/Practise/test.rb"
Number of paramters is: 2
Parameters are: dog
Parameters are: cat
Number of paramters is: 1
Parameters are: Tiger

[Done] exited with code=0 in 0.038 seconds

def para(*var)
    puts "number of parameters is: #{var.length}"

    for i in 0...var.length
        puts "Parameters are: #{var[i]}"
    end
end

para "Hi","Hello"
para "hihihi"
para "hello there","wassup","greetings"
[Running] ruby "/home/itsacheckmate/Practise/test.rb"
number of parameters is: 2
Parameters are: Hi
Parameters are: Hello
number of parameters is: 1
Parameters are: hihihi
number of parameters is: 3
Parameters are: hello there
Parameters are: wassup
Parameters are: greetings

[Done] exited with code=0 in 0.053 seconds

=>Return statement in Methods: Return statement used to returns one or more values. By default, a method always returns the last statement that was evaluated in the body of the method.
def num
    a=10
    b=39
    sum=a+b
        return sum
      
    end
puts "the result is: #{num}"
[Running] ruby "/home/itsacheckmate/Practise/test.rb"
the result is: 49

[Done] exited with code=0 in 0.044 seconds

=>Class Methods==>
  When a method is defined outside of the class definition, 
  the method is marked as private by default. On the other hand,
   the methods defined in the class definition are marked as 
   public by default. The default visibility and the private 
   mark of the methods can be changed by public or private of 
   the Module.

 to access a method of a class,  first 
need to instantiate the class. Then, using the object,  
can access any member of the class.

Ruby gives you a way to access a method without 
instantiating a class.
3.0.0 :009 > class Accounts
3.0.0 :010 >   def reading_charge
3.0.0 :011 >   end
3.0.0 :012 >   def Accounts.return_date
3.0.0 :013 >   end
3.0.0 :014 > end
 => :return_date 
3.0.0 :015 > Accounts.return_date
 => nil 
 To access this method, no need to create objects of the 
class Accounts

=>Ruby Alias Statement
This gives alias to methods or global variables
Aliases cannot be defined within the method body. 
The alias of the method keeps the current definition 
of the method, even when methods are overridden.

Syntax
alias method-name method-name
alias global-variable-name global-variable-name

3.0.0 :026 > alias sam geeks
 => nil 
3.0.0 :027 > sam "hello",1,324
Number of parameters is: 3
Parameters are: hello
Parameters are: 1
Parameters are: 324
 => 0...3 

3.0.0 :017 > class Microwave
3.0.0 :019 >     puts "The microwave is on"
3.0.0 :020 >   end
3.0.0 :021 >   alias :start :on
3.0.0 :022 > end
 => nil 
3.0.0 :023 > m=Microwave.new
 => #<Microwave:0x0000556fccde46a8> 
3.0.0 :024 > m.start
The microwave is on
 => nil 

=>Ruby Undef Statement
This cancels the method definition. An undef cannot appear in the method body.Syntax

Syntax:
undef method-name
3.0.0 :028 > undef sam
 => nil 
3.0.0 :029"> sam "hello"
Traceback (most recent call last):
        4: from /home/itsacheckmate/.rvm/rubies/ruby-3.0.0/bin/irb:23:in `<main>'
        3: from /home/itsacheckmate/.rvm/rubies/ruby-3.0.0/bin/irb:23:in `load'
        2: from /home/itsacheckmate/.rvm/rubies/ruby-3.0.0/lib/ruby/gems/3.0.0/gems/irb-1.3.0/exe/irb:11:in `<top (required)>'
        1: from (irb):29:in `<main>'
NoMethodError (undefined method `sam' for main:Object)
3.0.0 :030 > sample "windows","32","m","bca"

=> Ruby Blocks

A block is the same thing as a method, but it does not belong to an object.
A block consists of chunks of code.You assign a name to a block.
The code in the block is always enclosed within braces ({}).
We invoke a block by using the yield statement.
Syntax

block_name {
   statement1
   statement2
   ..........
}
3.0.0 :001 > def test
3.0.0 :002 >   puts "You are in the method"
3.0.0 :003 >   yield
3.0.0 :004 >   puts "You are again back to the method"
3.0.0 :005 >   yield
3.0.0 :006 > end
 => :test 
3.0.0 :007 > test {puts "You are in the block"}
You are in the method
You are in the block
You are again back to the method
You are in the block
 => nil 

The yield statement is written followed by parameters.
  You can even pass more than one parameter. In the block, 
  you place a variable between two vertical lines (||) to 
  accept the parameters. Therefore, in the preceding code,
   the yield 5 statement passes the value 5 as a parameter 
   to the test block.
   
   3.0.0 :009 > def test
3.0.0 :010 >   yield 5
3.0.0 :011 >   puts "you are in the method test"
3.0.0 :012 >   yield 100
3.0.0 :013 > end
 => :test 
3.0.0 :014 > test {|i| puts "You are the block #{i}"}
You are the block 5
you are in the method test
You are the block 100
 => nil 
 
 if you want to pass more than one parameters, then the yield statement becomes - 
 yield a, b==>
 3.0.0 :032 > def test
3.0.0 :033 >   yield 70,100
3.0.0 :034 >   puts "You are in the method test"
3.0.0 :035 >   yield 1000
3.0.0 :036 > end
 => :test 
3.0.0 :037 > test {|i,j| puts "You are in the block #{i} and #{j}"}
You are in the block 70 and 100
You are in the method test
You are in the block 1000 and 
 => nil 

But if the last argument of a method is preceded by &,
      then you can pass a block to this method and this 
      block will be assigned to the last parameter. In case
          both * and & are present in the argument list, & 
          should come later.
          
          3.0.0 :042 > def test(&block)
3.0.0 :043 >   block.call
3.0.0 :044 > end
 => :test 
Hello World!
 => nil 

#Module Ruby
A Module is a collection of methods, constants, and class variables.
You cannot inherit modules or you can’t create a subclass of a module.
Objects cannot be created from a module.
Modules are used as namespaces and as mixins.
All the classes are modules, but all the modules are not classes.
The name of a module must start with a capital letter.

Syntax:

module Module_name

   # statements to be executed

end

3.0.0 :069 > module Trig
3.0.0 :070 >   PI = 3.141592654
3.0.0 :071 >   def Trig.sin(x)
3.0.0 :072 >     # ..
3.0.0 :073 >   end
3.0.0 :074 >   def Trig.cos(x)
3.0.0 :075 >     # ..
3.0.0 :076 >   end
3.0.0 :077 > end
 => :cos 

module Gfg
    C=10;
    def Gfg.portal
        puts "Welcome!"
    end
    
    def Gfg.tutorial
        puts "Ruby tutorial"
    end
    def Gfg.topic
        puts "Topic - Module"
    end
end

puts Gfg::C

Gfg.portal
Gfg.tutorial
Gfg.topic
[Running] ruby "/home/itsacheckmate/Practise/test.rb"
10
Welcome!
Ruby tutorial
Topic - Module

include statement
embed a module in a class. To embed a module in a class,
 you use the include statement in the class
applying method

module=>
module Week
    FIRST_DAY = "Sunday"
    def Week.weeks_in_month
        puts "You have four weeks in a month"
    end
    def Week.weeks_in_year
        puts "You have 52 weeks in a year"
    end
end


code-->
class Decade
    include Week
    no_of_yrs=10
    def no_of_months
        puts Week::FIRST_DAY
        number=10*12
        puts number
    end
end
d1=Decade.new
puts Week::FIRST_DAY
Week.weeks_in_month
Week.weeks_in_year
d1.no_of_months

[Running] ruby "/home/itsacheckmate/Practise/test.rb"
Sunday
You have four weeks in a month
You have 52 weeks in a year
Sunday
120

[Done] exited with code=0 in 0.038 seconds

#Mixins in Ruby
Ruby does not support multiple inheritance.Mixins give you a wonderfully controlled way of adding functionality to classes.
to apply multiple inheritence in ruby mixins facility is provided

module A
    def a1
        puts "Method a1 of module A"
    end
    def a2
        puts "Method a2 of module A"
    end
end
module B                           
    def b1 
        puts "Method b1 of module B"
    end
    def b2
        puts "Method b2 of module B"
    end
end

class Sample
    include A
    include B
    def s1

    end
end
samp=Sample.new
samp.a1
samp.a2
samp.b1
samp.b2
samp.s1


[Running] ruby "/home/itsacheckmate/Practise/tempCodeRunnerFile.rb"
Method a1 of module A
Method a2 of module A
Method b1 of module B
Method b2 of module B

[Done] exited with code=0 in 0.047 seconds

The class sample can access all four methods a1,a2,b1 and b2 therefore class Sample inherits
from both the modules.

samp.s1


Ruby Iterators

Iterators are nothing but methods supported by collections. 
Objects that store a group of data members are called collections.
 In Ruby, arrays and hashes can be termed collections.

Iterators return all the elements of a collection, 
one after the other.

two common iterators are, each and collect

Ruby each Iterator
The each iterator returns all the elements of an array or a
 hash.

 Executes code for each element in collection. 
 Here, collection could be an array or a ruby hash.

Syntax
collection.each do |variable|
   code
end

3.0.0 :134 > ary = [1,2,3,4,5]
 => [1, 2, 3, 4, 5] 
3.0.0 :135 > ary.each do |i|
3.0.0 :136 >    puts i
3.0.0 :137 > end
1
2
3
4
5
 => [1, 2, 3, 4, 5] 


 Ruby collect Iterator
The collect iterator returns all the elements of a collection.
Syntax
collection = collection.collect

The collect method need not always be associated with a block.
 The collect method returns the entire collection,
 regardless of whether it is an array or a hash.
 
 #Iterators in Ruby
Iterators” is the object-oriented concept in Ruby.
In more simple words, iterators are the methods which are supported by collections(Arrays, Hashes etc.). 
Collections are the objects which store a group of data members.
Ruby iterators return all the elements of a collection one after another.

There are many iterators in Ruby as follows: 
1.Each Iterator
2.Collect Iterator
3.Times Iterator
4.Upto Iterator
5.Downto Iterator
6.Step Iterator
7.Each_Line Iterator


1.Each Iterator: This iterator returns all the elements of an array or a hash. Each iterator returns each value one by one. 
Syntax:
3.0.0 :001 > (0..9).each do |i|
3.0.0 :002 >   puts i
3.0.0 :003 > end
0
1
2
3
4
5
6
7
8
9
 => 0..9 
3.0.0 :004 > a = ['J', 'A', 'S', 'K', 'A', 'R', 'A', 'N']
 => ["J", "A", "S", "K", "A", "R", "A", "N"] 
3.0.0 :005 > puts "\n"

 => nil 
3.0.0 :006 > a.each do|arr|
3.0.0 :007 >   puts arr
3.0.0 :008 > end
J
A
S
K
A
R
A
N
 => ["J", "A", "S", "K", "A", "R", "A", "N"] 
 
 2.    Collect Iterator: This iterator returns all the elements of a collection. The collect iterator returns an entire collection, regardless of whether it is an array or hash.
    Syntax: 
    
Collection = collection.collect

3.0.0 :001 > a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
 => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 
3.0.0 :002 > b = a.collect{ |y| (5*y) }
 => [5, 10, 15, 20, 25, 30, 35, 40, 45, 50] 
3.0.0 :003 > puts b
5
10
15
20
25
30
35
40
45
50
 => nil 

3.Times Iterator: In this iterator, a loop is implanted with the specific number of time. The loop is initially started from zero and runs until the one less than the specified number.
    Syntax:
     

t.times do |variable_name|

# code to be execute

end

3.0.0 :004 > 7.times do |i|
3.0.0 :005 >   puts i
3.0.0 :006 > end
0
1
2
3
4
5
6
 => 7 
 
 4.Upto Iterator: This iterator follows top to bottom approach. It includes both the top and bottom variable in the iteration.
     Syntax: 
     

top.upto(bottom) do |variable_name|

# code to execute

end

3.0.0 :007 > 4.upto(7) do |n|
3.0.0 :008 >   puts n
3.0.0 :009 > end
4
5
6
7
 => 4 
3.0.0 :010 > 7.upto(4) do |n|
3.0.0 :011 >   puts n
3.0.0 :012 > end
 => 7 


5.    Downto Iterator: This iterator follows bottom to top approach. It includes both the top and bottom variable in the iteration. 
    Syntax: 
     

top.downto(bottom) do |variable_name|

# code to execute

end

3.0.0 :013 > 10.downto(5) do |n|
3.0.0 :014 >   puts n
3.0.0 :015 > end
10
9
8
7
6
5
 => 10 
3.0.0 :016 > 4.downto(7) do |n|
3.0.0 :017 >   puts n
3.0.0 :018 > end
 => 4 

    6.Step Iterator: Ruby step iterator is used to iterate where the user has to skip a specified range. 
    Syntax: 
     

Collection.step(rng) do |variable_name|

# code to be executed

end 

3.0.0 :019 > (0..100).step(20) do|i|
3.0.0 :020 >   puts i
3.0.0 :021 > end
0
20
40
60
80
100
 => 0..100
 
 7.Each_line Iterator: Ruby each_line iterator is used to iterate over a new line in the string. 
    Syntax:
     

string.each_line do |variable_name|

# code to be executed

end

3.0.0 :025 > "Today\nis\na\nrainyday".each_line do|i|
3.0.0 :026 >   puts i
3.0.0 :027 > end
Today
is
a
rainyday
 => "Today\nis\na\nrainyday" 


#Ruby - File I/O

Ruby provides a whole set of I/O-related methods implemented in the Kernel module. All the I/O methods are derived from the class IO.
The class IO provides all the basic methods, such as read, write, gets, puts, readline, getc, and printf.

puts statement - The puts statement instructs the program to display the value stored in the variable. This will add a new line at the end of each line it writes.
3.0.0 :001 > val1 = "this is a variable one"
 => "this is a variable one" 
3.0.0 :002 > val2 = "this is a variable two"
 => "this is a variable two" 
3.0.0 :003 > puts val1
this is a variable one
 => nil 
3.0.0 :004 > puts val2
this is a variable two
 => nil 
 
 gets statement - the gets statement is used to take any input from the user from standard screen called stdin.
 
 puts 'Enter your age'
val = gets
puts "Your age is #{val}"
itsacheckmate@itscheckmate:~/Practise$ ruby test.rb
Enter your age
20
Your age is 20


The putc Statement
Unlike the puts statement, which outputs the entire string onto the screen, the putc statement can be used to output one character at a time.
3.0.0 :008"> str = "Helo Ruby!"
 => "Helo Ruby!" 
3.0.0 :009 > putc str
H => "Helo Ruby!" 

The print Statement
The print statement is similar to the puts statement. The only difference is that the puts statement goes to the next line after printing the contents, whereas with the print statement the cursor is positioned on the same line.

print 'this will print'
print ' on the same line'

[Running] ruby "/home/itsacheckmate/Practise/test.rb"
this will print on the same line
[Done] exited with code=0 in 0.04 seconds

#file handling in ruby - 
It is a way of processing a file such as creating a new file, reading content in a file, writing content to a file, appending content to a file, renaming the file and deleting the file.

Common modes for File Handling
“r” : Read-only mode for a file.
“r+” : Read-Write mode for a file.
“w” : Write-only mode for a file.
“w+” : Read-Write mode for a file.
“a” : Write-only mode, if file exists it will append the data otherwise a new file will be created.
“a+” : Read and Write mode, if file exists it will append the data otherwise a new file will be created.

a text file named sample.txt is created with read and write permissions.The content  "File Handling" is written to the file using syswrite method.
fileobject = File.new("sample.txt", "w+");
fileobject.syswrite("File Handling in Ruby language");
fileobject.close();
itsacheckmate@itscheckmate:~/Practise$ cat sample.txt 
File Handling in ruby languageitsacheckmate@itscheckmate:~/Practise$ 

#you can use File.open method to create a new file object and assign that file object to a file.
however, there is a difference b/w File.open and File.new methods.the difference is that File.open method can be associated with a block,whereas you cannot do the same using the File.new method.

File.open("filename", "mode") do |aFile|
   # ... process the file
end

fileobject = File.open("sample.txt","r");
puts(fileobject.sysread(21)); //reading the first n characters
fileobject.close();
fileobject = File.open("sample.txt","r");
print(fileobject.readlines); //read the values as an array of lines
puts
fileobject.close();
fileobject = File.open("sample.txt","r");
print(fileobject.read()); //read the entire content from a file
fileobject.close();

itsacheckmate@itscheckmate:~/Practise$ ruby test.rb 
File Handling in ruby
["File Handling in ruby language"]
File Handling in ruby languageitsacheckmate@itscheckmate:~/Practise$

#the sysread method - You can use the method sysread to read the contents of a file. You can open the file in any of the modes when using the method sysread.
aFile =  File.new("input.txt", "r")
if aFile
    content = aFile.sysread(20)
    puts content
else
    puts "Unable to open file!"
end
itsacheckmate@itscheckmate:~/Practise$ ruby test.rb 
sample file for test


The syswrite Method
You can use the method syswrite to write the contents into a file
aFile = File.new("input.txt","r+")
if aFile
    aFile.syswrite("ABCDEF")
else
    puts "Unable to open file!"
end

#the each_byte method - this method belongs to the class File.The method each_byte is always associated with a block.
a_file = File.new("input.txt","r+")
if a_file
    a_file.syswrite("abcdef")
    a_file.each_byte {|ch| putc ch; putc ?. }
else
    puts "unable to open file!"
end
itsacheckmate@itscheckmate:~/Practise$ ruby test.rb 
 .f.i.l.e. .f.o.r. .t.e.s.t.itsacheckmate@itscheckmate:~/Practise$ 
 
 
 #The IO.readlines Method
 
 The class file is a subclass of the class IO.
 One of the IO class methods is IO.readlines.this method returns the contents of the file line by line.
 
 arr = IO.readlines("input.txt")
puts arr[0]
puts arr[1]
itsacheckmate@itscheckmate:~/Practise$ ruby test.rb 
abcdef
 file for test
 
 The IO.foreach Method
This method also returns output line by line. The difference between the method foreach and the method readlines is that the method foreach is associated with a block. However, unlike the method readlines, the method foreach does not return an array.

IO.foreach("input.txt"){|block| puts block}
itsacheckmate@itscheckmate:~/Practise$ ruby test.rb 
abcdef
 file for test
 
 #We can rename and delete files with ruby with rename and delete methods
 File.rename("input.txt","rename.txt")
 File.delete("rename.txt")
 
 
 #Use the chmod method with a mask to change the mode or permissions/access list of a file
 
 file = File.new("test.txt","w")
file.chmod(0755)

#File Inquiries

1.tests whether a file exists before opening it − File.open("file.rb") if File::exists( "file.rb" )

2. inquire whether the file is really a file - File.file?("sample.txt")

3. finds out if the given file name is a directory - 
3.0.0 :009 > File::directory?("/usr/local/bin" )
 => true 
3.0.0 :010 > File::directory?("Downloads" )
 => true 
3.0.0 :011 > File::directory?("File.rb" )
 => false 
3.0.0 :012


4.finds whether the file is readable, writable or executable -
3.0.0 :012 > File.readable?("Downloads")
 => true 
3.0.0 :013 > File.writable?("Downloads")
 => true 
3.0.0 :014 > File.executable?("Downloads")
 => true 

5.finds whether the file has zero size or not -
3.0.0 :002 > File.zero?("b.txt")
 => true 
 
 6.returns the size of the file-
3.0.0 :003 > File.size?("b.txt")
 => nil 
3.0.0 :004 > File.size?("Downloads")
 => 4096 

7.command can be used to find out a type of file -
3.0.0 :005 > File::ftype("Downloads")
 => "directory" 
3.0.0 :006 > File::ftype("b.txt")
 => "file" 
 
 The ftype method identifies the type of the file by returning one of the following − file, directory, characterSpecial, blockSpecial, fifo, link, socket, or unknown.
 
 8. command can be used to find when a file was created, modified, or last accessed -
 3.0.0 :007 > File::ctime("b.txt")
 => 2022-05-11 16:30:15.692459267 +0530 
3.0.0 :008 > File::mtime("b.txt")
 => 2022-05-11 16:30:15.68445929 +0530 
3.0.0 :009 > File::atime("b.txt")
 => 2022-05-11 16:30:15.68445929 +0530 

Directories in Ruby - 
the File class handles files, directories are handled with the Dir class.

1.to change directory within a ruby program - 
3.0.0 :010 > Dir.chdir("/usr/bin")
 => 0 

2.to view current directory -
3.0.0 :011 > puts Dir.pwd
/usr/bin
 => nil 
 
 3.list of the files and directories within a specific directory using Dir.entries-
 3.0.0 :012 > puts Dir.entries("/usr/bin").join(' ')

4.Dir.entries returns an array with all the entries within the specified directory. Dir.foreach provides the same feature −
3.0.0 :016 > Dir.foreach("/usr/bin") do |entry|
3.0.0 :017 >   puts entry
3.0.0 :018 > end

The Dir.mkdir can be used to create directories-
Dir.mkdir("mynewdir")
3.0.0 :001 > Dir.mkdir("mynewdir")
 => 0 
3.0.0 :002 > Dir.chdir("mynewdir")
 => 0 
3.0.0 :003 > puts Dir.pwd
/home/itsacheckmate/mynewdir
 => nil 

6.to delete the directory - 
Dir.delete("testdir")

#Creating Files & Temporary Directories - 
Temporary files are those that might be created briefly during a program's execution but aren't a permanent store of information.

require 'tmpdir'
tempfilename = File.join(Dir.tmpdir, "tingtong")
tempfile = File.new(tempfilename, "w")
tempfile.puts "This is a temporary file"
tempfile.close
File.delete(tempfilename)

This code creates a temporary file, writes data to it, and deletes it.




#Exception Handling - In Ruby, exception handling is a process which describes a way to handle the error raised in a program. Here, error means an unwanted or unexpected event, which occurs during the execution of a program, i.e. at run time, that disrupts the normal flow of the program’s instructions. So these types of errors were handled by the rescue block. Ruby also provides a separate class for an exception that is known as an Exception class which contains different types of methods.

Syntax:

begin
    raise
      # block where exception raise

    rescue
      # block where exception rescue
end


begin
    file = open("/unexistant file")
    if file
        puts "File opened successfully"
    end
rescue
    file = STDIN
end
print file, "==", STDIN, "\n"
itsacheckmate@itscheckmate:~/Practise$ ruby test.rb 
#<IO:0x0000558f5b489b90>==#<IO:0x0000558f5b489b90>



def raise_and_rescue
    begin   
        puts 'this is before exception arises'

        raise 'Exception created'

        puts 'after exception'

    rescue
        puts 'saved'
    end
    puts 'outside of the begin block'
end

raise_and_rescue

itsacheckmate@itscheckmate:~/Practise$ ruby test.rb 
this is before exception arises
saved
outside of the begin block


retry - you can capture an exception using rescue block and then use retry statement to execute begin block from beginning.

Syntax-
begin
   # Exceptions raised by this code will 
   # be caught by the following rescue clause
rescue
   # This block will capture all types of exceptions
   retry  # This will move control to the beginning of begin
end

begin
    
    raise 'Exception Created!'
    puts 'After exception'
    rescue 
    puts 'finally saved'
    retry
end

finally saved
finally saved
finally saved
finally saved
---

Raise - the raise statement is used to raise an exception.
Syntax-

raise 
OR
raise "Error Message" 
OR
raise ExceptionType, "Error Message"
OR
raise ExceptionType, "Error Message" condition

the first form simply re-raises the current exception,
the second form creates a new RunTimeError exception,setting its message to the given string.
the third form uses the first argument to create an exception and then sets the associated message to the second argument.
in fourth form it is similar to 3rd but you can add any conditional statement like unless to raise an exception.


begin
    
puts 'I am before the raise.'
raise 'An error has occurred'.
puts 'after the raise'
rescue
    puts ' after rescue'
    
end
puts ' after the begin block'
itsacheckmate@itscheckmate:~/Practise$ ruby test.rb 
I am before the raise.
 after rescue
 after the begin block
 
 
 begin
        raise 'A test exception.'
rescue Exception => e
    puts e.message
    puts e.backtrace.inspect
end
itsacheckmate@itscheckmate:~/Practise$ ruby test.rb 
A test exception.
["test.rb:2:in `<main>'"]


ensure Statement: This statement ensures that required instructions will execute at the end of the code, whether the exception raise or raised exception is rescued, or the program terminates due to an uncaught exception. This block always gives output. This block is placed over the rescue block.

Syntax:

begin
     # exception raise

rescue
    # exception rescue

ensure
    # this block always executes
end

begin     
    puts 'I am not raising an exception.'
rescue Exception => e
   puts e.message
   puts e.backtrace.inspect
else
    puts "Congratulations-- no errors!"
ensure
    puts "Ensuring execution"
end

[Running] ruby "/home/itsacheckmate/Practise/test.rb"
I am not raising an exception.
Congratulations-- no errors!
Ensuring execution

catch and throw - in Ruby, catch and throw blocks are the lightweight mechanism for error handling and used to jump from the exception when there is no additional work is available in the program.
The catch block is used to jump out from the nested block and the block is labeled with a name. 
This block works normally until it encounters with the throw block. catch and throw method will work faster than raise and rescue method. When the throw statement is encountered, 
Ruby will check the call stack for the catch statement with the related symbol. 
The throw statement never executes and always return nil.

def promptAndGet(prompt)
    puts prompt
    res = readline.chomp
     throw :quitRequested if res == "!"
     return res
end

catch :quitRequested do
    name = promptAndGet("Name: ")
    age = promptAndGet("Age: ")
    city = promptAndGet("City: ")
end
promptAndGet("Name:")

itsacheckmate@itscheckmate:~/Practise$ ruby test.rb 
Name: 
Jaskaran
Age: 
20
City: 
Chandigarh
Name:
Just Ruby


Class Exception

Ruby's standard classes and modules raise exceptions. All the exception classes form a hierarchy, with the class Exception at the top. The next level contains seven different types −

    Interrupt
    NoMemoryError
    SignalException
    ScriptError
    StandardError
    SystemExit
    

There is one other exception at this level, Fatal, but the Ruby interpreter only uses this internally.

3.0.0 :019 > class FileSaveError < StandardError
3.0.0 :020 >   attr_reader :reason
3.0.0 :021 >   def initialize(reason)
3.0.0 :022 >     @reason = reason
3.0.0 :023 >   end
3.0.0 :024 > end
 => :initialize 
3.0.0 :025 > File.open(path, "w") do |file|
3.0.0 :026 >   begin
3.0.0 :027 >     hello hi
3.0.0 :028 >   rescue
3.0.0 :029 >     raise FileSaveError.new($!)
3.0.0 :030 >   end
3.0.0 :031 > end

Partition:
3.0.0 :001 > def split_odds_evens(nums)
3.0.0 :002 >   odd = []
3.0.0 :003 >   evens = []
3.0.0 :004 >   nums.each do |num|
3.0.0 :006 >       odd << num
3.0.0 :007 >     else
3.0.0 :008 >       even << num
3.0.0 :009 >     end
3.0.0 :010 >   end
3.0.0 :011 >   [odd, even]
3.0.0 :012 > end
 => :split_odds_evens 
3.0.0 :013 > def odd_even_short(nums)
3.0.0 :014 >   nums.partition(&:odd?)
3.0.0 :015 > end
 => :odd_even_short 
3.0.0 :016 > odd_even_short(3)

# select/reject:
select iterates over an enumerable and returns only the elements that answer the given block. 
rejects acts the same but opposite, it returns the ones that don’t answer the condition:
3.0.0 :021 >     result << num if num.odd?
3.0.0 :022 >   end
3.0.0 :023 >   result 
3.0.0 :024 > end
 => :only_odds 
3.0.0 :025 > def only_odds_object(nums)
3.0.0 :026 >   nums.each_with_

nums.each_with_index
nums.each_with_object
3.0.0 :025 > def only_odds_object(nums)
3.0.0 :026 >   nums.each_with_object([]) do |num, arr|
3.0.0 :027 >     arr << num if num.odd?
3.0.0 :028 >   end
3.0.0 :029 > end
 => :only_odds_object 
3.0.0 :030 > def only_odds_simple(nums)
3.0.0 :031 >   nums.select(&:odd?)
3.0.0 :032 > end
 => :only_odds_simple 
3.0.0 :033 > def only_odds(nums)
3.0.0 :034 >   nums.reject(&:even?)
3.0.0 :035 > end
 => :only_odds 
3.0.0 :036 > 

# any?/all?:
any? checks that at least one element in an enumerable corresponds to a condition. 
all? verifies that all elements fit the bill.
3.0.0 :036 > def all_odds(nums)
3.0.0 :037 >   nums.each do |num|
3.0.0 :038 >     return false if num.even?
3.0.0 :039 >   end
3.0.0 :040 >   true
3.0.0 :041 > end
 => :all_odds 
3.0.0 :042 > def easier_all_odds?(nums)
3.0.0 :043 >   nums.all?(&:odd?)
3.0.0 :044 > end
 => :easier_all_odds? 
3.0.0 :045 > def any_greater_than?(nums, x)
3.0.0 :046 >   nums.each do |num|
3.0.0 :047 >     return true if num > x
3.0.0 :048 >   end
3.0.0 :049 >   return false
3.0.0 :050 > end
 => :any_greater_than? 
3.0.0 :051 > def easier_any_greater_than?(nums, x)
3.0.0 :052 >   nums.any?{ |num| num > x}
3.0.0 :053 > end
 => :easier_any_greater_than? 

