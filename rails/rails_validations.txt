Validations are used to ensure that only valid data is saved into your database. For example, it may be important to your application to ensure that every user provides a valid email address and mailing address. Model-level validations are the best way to ensure that only valid data is saved into your database. They are database agnostic, cannot be bypassed by end users, and are convenient to test and maintain. Rails provides built-in helpers for common needs, and allows you to create your own validation methods as well.

3.0.0 :005 > book.title = "The Power of your subconscious mind"
 => "The Power of your subconscious mind" 
3.0.0 :006 > book.new_record?
 => true 
3.0.0 :007 > book.save
  TRANSACTION (0.3ms)  BEGIN
  Book Create (3.1ms)  INSERT INTO "books" ("title", "total_page", "rating", "price", "created_at", "updated_at", "date_published", "publisher_id") VALUES ($1, $2, $3, $4, $5, $6, $7, $8) RETURNING "id"  [["title", "The Power of your subconscious mind"], ["total_page", nil], ["rating", nil], ["price", nil], ["created_at", "2022-05-27 08:52:13.257238"], ["updated_at", "2022-05-27 08:52:13.257238"], ["date_published", nil], ["publisher_id", nil]]                       
  TRANSACTION (0.9ms)  COMMIT                                      
 => true                                                           
3.0.0 :008 > book.new_record?
 => false 

The following methods trigger validations, and will save the object to the database only if the object is valid:

    create
    create!
    save
    save!
    update
    update!

The bang versions (e.g. save!) raise an exception if the record is invalid. The non-bang versions don't: save and update return false, and create returns the object.

3.0.0 :009 > book.save!
 => true 

Skipping Validations - 
1.increment!

3.0.0 :017 > book.increment!(:total_page)
  Book Update All (7.4ms)  UPDATE "books" SET "total_page" = COALESCE("total_page", 0) + $1 WHERE "books"."id" = $2  [["total_page", 1], ["id", 6]]
 =>                                                                                    
#<Book:0x000056510da1f310                                                              
 id: 6,                                                                                
 title: "The Power of the Subconcious mind",                                           
 total_page: 239,                                                                      
 rating: nil,                                                                          
 price: nil,                                                                           
 created_at: Fri, 27 May 2022 08:52:13.257238000 UTC +00:00,                           
 updated_at: Fri, 27 May 2022 08:54:06.162250000 UTC +00:00,                           
 date_published: nil,                                                                  
 publisher_id: nil>                                                                    
3.0.0 :018 > 
    
2.decrement! -
3.0.0 :018 > book.decrement!(:total_page)
  Book Update All (7.6ms)  UPDATE "books" SET "total_page" = COALESCE("total_page", 0) - $1 WHERE "books"."id" = $2  [["total_page", 1], ["id", 6]]
 =>                                                                                    
#<Book:0x000056510da1f310                                                              
 id: 6,                                                                                
 title: "The Power of the Subconcious mind",                                           
 total_page: 238,                                                                      
 rating: nil,                                                                          
 price: nil,                                                                           
 created_at: Fri, 27 May 2022 08:52:13.257238000 UTC +00:00,                           
 updated_at: Fri, 27 May 2022 08:54:06.162250000 UTC +00:00,                           
 date_published: nil,                                                                  
 publisher_id: nil> 
 
 valid? and invalid?
 
Before saving an Active Record object, Rails runs your validations. If these validations produce any errors, Rails does not save the object.
 
 3.0.0 :024 > Author.create(name: "John Doe").valid?
  TRANSACTION (0.4ms)  BEGIN
  Author Create (3.3ms)  INSERT INTO "authors" ("name", "dob", "gender", "country", "created_at", "updated_at", "lock_version") VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING "id"  [["name", "John Doe"], ["dob", nil], ["gender", nil], ["country", nil], ["created_at", "2022-05-27 10:00:53.813532"], ["updated_at", "2022-05-27 10:00:53.813532"], ["lock_version", 0]]                    
  
  
  3.0.0 :002 > Customer.create(name: nil).valid?
  TRANSACTION (0.2ms)  BEGIN
  Customer Create (7.6ms)  INSERT INTO "customers" ("name", "address", "gender", "mobile", "check_in", "check_out", "created_at", "updated_at", "country") VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9) RETURNING "id"  [["name", nil], ["address", nil], ["gender", nil], ["mobile", nil], ["check_in", nil], ["check_out", nil], ["created_at", "2022-05-27 10:04:16.509013"], ["updated_at", "2022-05-27 10:04:16.509013"], ["country", nil]]                                                 
  TRANSACTION (0.2ms)  ROLLBACK                                                 
/home/itsacheckmate/.rvm/gems/ruby-3.0.0/gems/activerecord-7.0.3/lib/active_record/connection_adapters/postgresql_adapter.rb:768:in `exec_params': PG::NotNullViolation: ERROR:  null value in column "name" violates not-null constraint (ActiveRecord::NotNullViolation)                                                      
DETAIL:  Failing row contains (23, null, null, null, null, null, null, 2022-05-27 10:04:16.509013, 2022-05-27 10:04:16.509013, null).                           
/home/itsacheckmate/.rvm/gems/ruby-3.0.0/gems/activerecord-7.0.3/lib/active_record/connection_adapters/postgresql_adapter.rb:768:in `exec_params': ERROR:  null value in column "name" violates not-null constraint (PG::NotNullViolation)
DETAIL:  Failing row contains (23, null, null, null, null, null, null, 2022-05-27 10:04:16.509013, 2022-05-27 10:04:16.509013, null).

3.0.0 :009 > c = Customer.new
 => 
#<Customer:0x00007f2134479940                                       
...                                                                 
3.0.0 :010 > c.errors.size
 => 0 
3.0.0 :012 > c.errors.objects.first.full_message
(irb):12:in `<main>': undefined method `full_message' for nil:NilClass (NoMethodError)                                                                          
3.0.0 :013 > c.save 
  TRANSACTION (0.4ms)  BEGIN
  Customer Create (1.2ms)  INSERT INTO "customers" ("name", "address", "gender", "mobile", "check_in", "check_out", "created_at", "updated_at", "country") VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9) RETURNING "id"  [["name", nil], ["address", nil], ["gender", nil], ["mobile", nil], ["check_in", nil], ["check_out", nil], ["created_at", "2022-05-27 10:12:36.964099"], ["updated_at", "2022-05-27 10:12:36.964099"], ["country", nil]]                                                 
  TRANSACTION (0.3ms)  ROLLBACK                                                 
/home/itsacheckmate/.rvm/gems/ruby-3.0.0/gems/activerecord-7.0.3/lib/active_record/connection_adapters/postgresql_adapter.rb:768:in `exec_params': PG::NotNullViolation: ERROR:  null value in column "name" violates not-null constraint (ActiveRecord::NotNullViolation)                                                      
DETAIL:  Failing row contains (24, null, null, null, null, null, null, 2022-05-27 10:12:36.964099, 2022-05-27 10:12:36.964099, null).                           
/home/itsacheckmate/.rvm/gems/ruby-3.0.0/gems/activerecord-7.0.3/lib/active_record/connection_adapters/postgresql_adapter.rb:768:in `exec_params': ERROR:  null value in column "name" violates not-null constraint (PG::NotNullViolation)
DETAIL:  Failing row contains (24, null, null, null, null, null, null, 2022-05-27 10:12:36.964099, 2022-05-27 10:12:36.964099, null).
3.0.0 :014 > 

3.0.0 :014 > c.save!
  TRANSACTION (0.4ms)  BEGIN
  Customer Create (0.9ms)  INSERT INTO "customers" ("name", "address", "gender", "mobile", "check_in", "check_out", "created_at", "updated_at", "country") VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9) RETURNING "id"  [["name", nil], ["address", nil], ["gender", nil], ["mobile", nil], ["check_in", nil], ["check_out", nil], ["created_at", "2022-05-27 10:12:36.964099"], ["updated_at", "2022-05-27 10:12:36.964099"], ["country", nil]]                          
  TRANSACTION (0.2ms)  ROLLBACK                          
/home/itsacheckmate/.rvm/gems/ruby-3.0.0/gems/activerecord-7.0.3/lib/active_record/connection_adapters/postgresql_adapter.rb:768:in `exec_params': PG::NotNullViolation: ERROR:  null value in column "name" violates not-null constraint (ActiveRecord::NotNullViolation)                               
DETAIL:  Failing row contains (25, null, null, null, null, null, null, 2022-05-27 10:12:36.964099, 2022-05-27 10:12:36.964099, null).    
/home/itsacheckmate/.rvm/gems/ruby-3.0.0/gems/activerecord-7.0.3/lib/active_record/connection_adapters/postgresql_adapter.rb:768:in `exec_params': ERROR:  null value in column "name" violates not-null constraint (PG::NotNullViolation)
DETAIL:  Failing row contains (25, null, null, null, null, null, null, 2022-05-27 10:12:36.964099, 2022-05-27 10:12:36.964099, null).

3.0.0 :015 > Customer.create!
  T3.0.0 :018 > customer.invalid?
 => false 
3.0.0 :019 > customer.invalid?(:new)
 => false 
RANSACTION (0.3ms)  BEGIN
  Customer Create (1.3ms)  INSERT INTO "customers" ("name", "address", "gender", "mobile", "check_in", "check_out", "created_at", "updated_at", "country") VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9) RETURNING "id"  [["name", nil], ["address", nil], ["gender", nil], ["mobile", nil], ["check_in", nil], ["check_out", nil], ["created_at", "2022-05-27 10:13:15.766634"], ["updated_at", "2022-05-27 10:13:15.766634"], ["country", nil]]                                 
  TRANSACTION (0.3ms)  ROLLBACK                                 
/home/itsacheckmate/.rvm/gems/ruby-3.0.0/gems/activerecord-7.0.3/lib/active_record/connection_adapters/postgresql_adapter.rb:768:in `exec_params': PG::NotNullViolation: ERROR:  null value in column "name" violates not-null constraint (ActiveRecord::NotNullViolation)                                      
DETAIL:  Failing row contains (26, null, null, null, null, null, null, 2022-05-27 10:13:15.766634, 2022-05-27 10:13:15.766634, null).           
/home/itsacheckmate/.rvm/gems/ruby-3.0.0/gems/activerecord-7.0.3/lib/active_record/connection_adapters/postgresql_adapter.rb:768:in `exec_params': ERROR:  null value in column "name" violates not-null constraint (PG::NotNullViolation)
DETAIL:  Failing row contains (26, null, null, null, null, null, null, 2022-05-27 10:13:15.766634, 2022-05-27 10:13:15.766634, null).

3.0.0 :018 > customer.invalid?
 => false 
3.0.0 :019 > customer.invalid?(:new)
 => false 

errors[] -
To verify whether or not a particular attribute of an object is valid, you can use errors[:attribute]. 
 It returns an array of all the error messages for :attribute. 
 It only checks to see whether there are errors found on an individual attribute of the object.

.0.0 :001 > customer = Customer.new
 => #<Customer:0x000055e2d66cdab8 id: nil, name: nil, address: nil, gender: nil, mobile: nil, check_in: nil, check_out: nil, created_at: nil, updated_at: nil, country: nil> 
3.0.0 :002 > customer.errors[:name]
 => [] 
3.0.0 :003 > customer.save
 => false 
3.0.0 :004 > customer.save!
/home/itsacheckmate/.rvm/gems/ruby-3.0.0/gems/activerecord-7.0.3/lib/active_record/validations.rb:80:in `raise_validation_error': Validation failed: Name can't be blank (ActiveRecord::RecordInvalid)
3.0.0 :005 > customer.errors[:name]
 => ["can't be blank"] 
3.0.0 :006 > customer.errors.objects.first
 => #<ActiveModel::Error attribute=name, type=blank, options={}> 
3.0.0 :007 > customer.errors.objects.first.all
(irb):7:in `<main>': undefined method `all' for #<ActiveModel::Error attribute=name, type=blank, options={}> (NoMethodError)
3.0.0 :008 > customer.errors.objects.first.full_message
 => "Name can't be blank" 
3.0.0 :010 > Customer.create.errors[:name].any?
 => true 
 
Acceptance -
This method validates that a checkbox on the user interface was checked when a form was submitted. This is typically used when the user needs to agree to your application's terms of service, confirm that some text is read, or any similar concept.If you dont have a field for it, the helper will create a virtual attribute. 
If the field does exist in your database, the accept option must be set to or include true or else the validation will not run.
 
 3.0.0 :010 > customer.save!
/home/itsacheckmate/.rvm/gems/ruby-3.0.0/gems/activerecord-7.0.3/lib/active_record/validations.rb:80:in `raise_validation_error': Validation failed: Available Accept this (ActiveRecord::RecordInvalid)         
 
confirmation

You should use this helper when you have two text fields that should receive exactly the same content.
 
 3.0.0 :002 > customer.address = "sector 14 Faridabad"
 => "sector 14 Faridabad" 
3.0.0 :003 > customer.address_confirmation = "sector 15 faridabad"
 => "sector 15 faridabad" 
3.0.0 :004 > customer.valid?
 => false 
3.0.0 :005 > customer.errors
 => #<ActiveModel::Errors [#<ActiveModel::Error attribute=name, type=blank, options={}>, #<ActiveModel::Error attribute=address_confirmation, type=confirmation, options={:attribute=>"Address"}>]>                                        
3.0.0 :006 > 

comparison

This check will validate a comparison between any two comparable values. The validator requires a compare option be supplied. Each option accepts a value, proc, or symbol. Any class that includes Comparable can be compare.

3.0.0 :002 > c.check_in = "2022/05/10"
 => "2022/05/10" 
3.0.0 :003 > c.check_out="2022/05/09"
 => "2022/05/09" 
3.0.0 :004 > c.save
 => false 

:greater_than_or_equal_to - Specifies the value must be greater than or equal to the supplied value. The default error message for this option is "must be greater than or equal to %{count}".
3.0.0 :013 > customer.errors.objects.first.full_message
 => "Check out must be greater than or equal to 2022-05-05" 

:equal_to - Specifies the value must be equal to the supplied value. The default error message for this option is "must be equal to %{count}".
3.0.0 :010 > customer.errors.objects.first.full_message
 => "Check out must be equal to 2022-06-06" 

:less_than - Specifies the value must be less than the supplied value. The default error message for this option is "must be less than %{count}".
3.0.0 :014 > customer.errors.objects.first.full_message
 => "Check in must be less than 2022-05-09" 
 
 :less_than_or_equal_to - Specifies the value must be less than or equal to the supplied value. The default error message for this option is "must be less than or equal to %{count}".
 3.0.0 :015 > customer.errors.objects.first.full_message
 => "Check in must be less than or equal to 2022-05-08" 

:other_than - Specifies the value must be other than the supplied value. The default error message for this option is "must be other than %{count}".

3.0.0 :014 > customer.errors.objects.first.full_message
 => "Check in must be other than 2022-05-05" 


exclusion

This helper validates that the attributes' values are not included in a given set. In fact, this set can be any enumerable object.
#<Author:0x00007f0fec542308                                            
 id: 10010,                                                            
 name: nil,                                                            
 dob: nil,                                                             
 gender: nil,                                                          
 country: nil,                                                         
 created_at: Fri, 27 May 2022 15:16:02.223858000 UTC +00:00,
 updated_at: Fri, 27 May 2022 15:16:02.223858000 UTC +00:00,
 lock_version: 0>      
3.0.0 :003 > author.country = "ca"
 => "ca" 
3.0.0 :004 > author.save
 => false 


3.0.0 :006 > author.errors.objects.first.full_message
 => "Country ca is reserved." 


This helper validates the attributes' values by testing whether they match a given regular expression, which is specified using the :with option.

 3.0.0 :004 > customer.errors.objects.first.full_message
 => "Email address is invalid" 
 
  inclusion
 This helper validates that the attributes values are included in a given set.
    In fact, this set can be any enumerable object.
    The inclusion helper has an option :in that receives the set of values that will be accepted. 
  The :in option has an alias called :within that you can use for the same purpose, if youd like to.
 
 3.0.0 :002 > a.name = "Mr"
 => "Mr" 
3.0.0 :003 > a.valid?
 => true
 
 
  7. presence
 This helper validates that the specified attributes are not empty.
It uses the blank? method to check if the value is either nil or a blank string, that is, a string that is either empty or consists of whitespace.
eg.   has_many :line_items, inverse_of: :order

8. absence
This helper validates that the specified attributes are absent.
 It uses the present? method to check if the value is not either nil or a blank string,
 that is, a string that is either empty or consists of whitespace.
 
 3.0.0 :010 > book.errors.objects.first.full_message

 length
This helper validates the length of the attributes' values. It provides a variety of options, so you can specify length constraints in different ways:
3.0.0 :009 > c.name = "w"
 => "w" 
3.0.0 :010 > c.valid?
 => false 
3.0.0 :011 > c.errors.object.first.full_message
(irb):11:in `<main>': undefined method `object' for #<ActiveModel::Errors [#<ActiveModel::Error attribute=address_confirmation, type=blank, options={}>, #<ActiveModel::Error attribute=check_out, type=blank, options={:count=>nil, :value=>nil}>, #<ActiveModel::Error attribute=name, type=too_short, options={:count=>2}>]> (NoMethodError)
Did you mean?  objects                                                                      
3.0.0 :012 > c.address = "sector 10"
 => "sector 10" 
3.0.0 :013 > c.gender = "male"
 => "male" 
3.0.0 :014 > c.mobile="2313433433"
 => "2313433433" 
3.0.0 :015 > c.check_in="2022/05/05"
 => "2022/05/05" 
3.0.0 :016 > c.check_out="2022/05/10"
 => "2022/05/10" 
3.0.0 :017 > c.country="Faridabad"
 => "Faridabad" 
3.0.0 :018 > s.save
(irb):18:in `<main>': undefined local variable or method `s' for main:Object (NameError)
3.0.0 :019 > c.save
 => false 
3.0.0 :037 > c.errors.objects.first.full_message
 => "Address is too long (maximum is 10 characters)" 
 

numericality 
 This helper validates that your attributes have only numeric values.
 By default, it will match an optional sign followed by an integer or floating point number

 The default error message for :only_integer is "must be an integer".

Besides :only_integer, this helper also accepts the following options to add constraints to acceptable values:

:greater_than - Specifies the value must be greater than the supplied value. The default error message for this option is "must be greater than %{count}".
:greater_than_or_equal_to - Specifies the value must be greater than or equal to the supplied value. The default error message for this option is "must be greater than or equal to %{count}".
:equal_to - Specifies the value must be equal to the supplied value. The default error message for this option is "must be equal to %{count}".
:less_than - Specifies the value must be less than the supplied value. The default error message for this option is "must be less than %{count}".
:less_than_or_equal_to - Specifies the value must be less than or equal to the supplied value. The default error message for this option is "must be less than or equal to %{count}".
:other_than - Specifies the value must be other than the supplied value. The default error message for this option is "must be other than %{count}".
:in - Specifies the value must be in the supplied range. The default error message for this option is "must be in %{count}".
:odd - Specifies the value must be an odd number if set to true. The default error message for this option is "must be odd".
:even - Specifies the value must be an even number if set to true. The default error message for this option is "must be even".

3.0.0 :002 > room.price = "1000"
 => "1000" 
3.0.0 :003 > room.customer_id = 1
 => 1 
3.0.0 :004 > room.customer_id = 4
 => 4 
3.0.0 :005 > room.type = "One-Bedroom"
 => "One-Bedroom" 
3.0.0 :006 > room.save
 => false 
3.0.0 :007 > room.valid?
 => false 
3.0.0 :008 > room.errors.objects.first.full_message
 => "Customer must be odd" 
3.0.0 :009 > 
3.0.0 :013 > room.price = 60000
 => 60000 
3.0.0 :014 > room.valid?
 => false 
3.0.0 :015 > room.errors.objects.first.full_message
 => "Price must be in 1000..5999" 

absence
This helper validates that the specified attributes are absent. It uses the present? method to check if the value is not either nil or a blank string, that is, a string that is either empty or consists of whitespace.
#<Customer:0x00007fa32cad3c58                                   
 id: nil,                                                       
 name: "Sam",                                                   
 address: "Faridabad",                                          
 gender: nil,                                                   
 mobile: "9876573100",                                          
 check_in: Tue, 10 May 2022,                                    
 check_out: Sat, 14 May 2022,                                   
 created_at: nil,                                               
 updated_at: nil,                                               
 country: "India">                                              
3.0.0 :009 > customer.save
 => false 
3.0.0 :010 > customer.errors.objects.first.full_message
 => "Address confirmation can't be blank" 
3.0.0 :011 > customer.address_confirmation = "Faridabad"
 => "Faridabad" 
3.0.0 :012 > customer.save
  TRANSACTION (0.3ms)  BEGIN
  Customer Create (6.0ms)  INSERT INTO "customers" ("name", "address", "gender", "mobile", "check_in", "check_out", "created_at", "updated_at", "country") VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9) RETURNING "id"  [["name", "Sam"], ["address", "Faridabad"], ["gender", nil], ["mobile", "9876573100"], ["check_in", "2022-05-10"], ["check_out", "2022-05-14"], ["created_at", "2022-05-31 10:57:14.180986"], ["updated_at", "2022-05-31 10:57:14.180986"], ["country", "India"]]                                
  TRANSACTION (0.6ms)  COMMIT                                                                       
 => true                                                                                            
3.0.0 :013 > customer.gender
 => nil 

 uniqueness
This helper validates that the attributes value is unique right before the object gets saved. 
It does not create a uniqueness constraint in the database, so it may happen that two different 
database connections create two records with the same value for a column that you intend to be unique.

There is a :scope option that you can use to specify one or more attributes that are used to limit the uniqueness check.
There is also a :case_sensitive option that you can use to define whether the uniqueness constraint will be case sensitive, case insensitive, or respects default database collation.
The default error message is "has already been taken".
The scope option to the Rails uniqueness validation rule allows us to specify additional columns to consider when checking for uniqueness. This rule says that “the name of this project must unique, within the scope of this account”.
 id: 1,                                                                    
 name: "Jaskaran Singh",                                                   
 address: "#Sector 20-A Chandigarh",                                       
 gender: "Male",                                                
 mobile: "9876573100",                                          
 check_in: Sun, 01 May 2022,                                    
 check_out: Tue, 10 May 2022,                                   
 created_at: Mon, 23 May 2022 10:03:11.423908000 UTC +00:00,    
 updated_at: Mon, 23 May 2022 10:05:42.660282000 UTC +00:00,    
 country: "India">                             
3.0.0 :016 > customer = Customer,new
(irb):16:in `<main>': undefined local variable or method `new' for main:Object (NameError)
Did you mean?  next                                             
3.0.0 :017 > customer = Customer.new
 => #<Customer:0x000055f0f2428db0 id: nil, name: nil, address: nil, gender: nil, mobile: nil, check_in: nil, check_out: nil, created_at: nil, updated_at: nil, country: nil> 
3.0.0 :018 > customer.name = "Jaskaran Singh"
 => "Jaskaran Singh" 
3.0.0 :022 > customer.errors.messages
 =>:name=>["has already been taken"]} 


 Common Validation Options
1.The :allow_nil option skips the validation when the value being validated is nil.
#<Customer:0x0000558cab95f780                                   
 id: 32,                                                        
 name: "Uchiha",                                                
 address: "chd",                                                
 gender: nil,                 
 mobile: "9876573100",        
 check_in: Thu, 05 May 2022,  
 check_out: Tue, 10 May 2022, 
 created_at: Tue, 31 May 2022 12:50:22.377050000 UTC +00:00,
 updated_at: Tue, 31 May 2022 12:50:22.377050000 UTC +00:00,
 country: "india">   
 
 2.allow_blank - 
 The :allow_blank option is similar to the :allow_nil option. This option will let validation pass if the attribute's value is blank?, like nil or an empty string for example.
 3.0.0 :006 > customer.name = "Jas"
 => "Jas" 
3.0.0 :007 > customer.check_out = ""
 => "" 
3.0.0 :008 > customer.check_out.valid?
(irb):8:in `<main>': undefined method `valid?' for nil:NilClass (NoMethodError)
3.0.0 :009 > customer.save
  TRANSACTION (0.2ms)  BEGIN
  Customer Create (0.2ms)  INSERT INTO "customers" ("name", "address", "gender", "mobile", "check_in", "check_out", "created_at", "updated_at", "country") VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9) RETURNING "id"  [["name", "Jas"], ["address", nil], ["gender", nil], ["mobile", nil], ["check_in", nil], ["check_out", nil], ["created_at", "2022-05-31 12:58:41.611610"], ["updated_at", "2022-05-31 12:58:41.611610"], ["country", nil]]                                                            
  TRANSACTION (0.7ms)  COMMIT                                                            
 => true                                                                                 
3.0.0 :010 > customer.valid?
 => true 
3.0.0 :011 > 


.3 :message

. The :message option accepts a String or Proc.
A String :message value can optionally contain any/all of %{value}, %{attribute}, and %{model} which will be dynamically replaced when validation fails. This replacement is done using the I18n gem, and the placeholders must match exactly, no spaces are allowed.
A Proc :message value is given two arguments: the object being validated, and a hash with :model, :attribute, and :value key-value pairs.

3.0.0 :007 > customer.errors.messages
 => 
{:name=>["must be given please", "is too short (minimum is 2 characters)"],           
 :address_confirmation=>["can't be blank"],                     
 :check_in=>["can't be blank", "has already been taken"],       
 :address=>["City seems wrong"],                                      
 :mobile=>["is the wrong length (should be 10 characters)"]}    
3.0.0 :010 > author.name = "David Goggins"
 => "David Goggins" 
3.0.0 :011 > author.save
  TRANSACTION (0.3ms)  BEGIN
  Author Exists? (7.3ms)  SELECT 1 AS one FROM "authors" WHERE "authors"."name" = $1 LIMIT $2  [["name", "David Goggins"], ["LIMIT", 1]]               
  TRANSACTION (0.4ms)  ROLLBACK                                        
 => false                                                              
3.0.0 :012 > author.errors.messages
 => 
{:email_address=>["is invalid"],                                                
 :name=>["Hey David Goggins, David Goggins is already taken"]}   
 
 :on
The :on option lets you specify when the validation should happen. The default behavior for all the built-in validation helpers is to be run on save (both when you're creating a new record and when you're updating it). If you want to change it, you can use on: :create to run the validation only when a new record is created or on: :update to run the validation only when a record is updated.

Loading development environment (Rails 7.0.3)                 
3.0.0 :001 > author = Author.create(email_address: "david@gmail.com")
  TRANSACTION (0.1ms)  BEGIN
  Author Exists? (0.3ms)  SELECT 1 AS one FROM "authors" WHERE "authors"."name" IS NULL LIMIT $1  [["LIMIT", 1]]
  Author Exists? (1.9ms)  SELECT 1 AS one FROM "authors" WHERE "authors"."email_address" = $1 LIMIT $2  [["email_address", "david@gmail.com"], ["LIMIT", 1]]
  TRANSACTION (0.1ms)  ROLLBACK                               
 => #<Author:0x000056018cf69f30 id: nil, name: nil, dob: nil, gender: nil, country: nil, created_at: nil, updated_at: nil, lock_version: 0, email_address: "david@gmail.com"> 
3.0.0 :002 > author.errors.messages
 => {:name=>["Hey ,  is already taken"], :email_address=>["has already been taken"]} 
 You can also use on: to define custom contexts. Custom contexts need to be triggered explicitly by passing the name of the context to valid?, invalid?, or save.
 
 3.0.0 :005 > author.email_address = "rahul@gmail.com"
 => "rahul@gmail.com" 
3.0.0 :006 > author.name = "Rahul"
 => "Rahul" 
3.0.0 :007 > author.save
  TRANSACTION (0.4ms)  BEGIN
  Author Exists? (1.0ms)  SELECT 1 AS one FROM "authors" WHERE "authors"."name" = $1 LIMIT $2  [["name", "Rahul"], ["LIMIT", 1]]
  Author Exists? (2.6ms)  SELECT 1 AS one FROM "authors" WHERE "authors"."email_address" = $1 LIMIT $2  [["email_address", "rahul@gmail.com"], ["LIMIT", 1]]
  Author Create (8.1ms)  INSERT INTO "authors" ("name", "dob", "gender", "country", "created_at", "updated_at", "lock_version", "email_address") VALUES ($1, $2, $3, $4, $5, $6, $7, $8) RETURNING "id"  [["name", "Rahul"], ["dob", "1990-05-10"], ["gender", nil], ["country", nil], ["created_at", "2022-05-31 13:44:33.340343"], ["updated_at", "2022-05-31 13:44:33.340343"], ["lock_version", 0], ["email_address", "rahul@gmail.com"]]                                     
  TRANSACTION (1.0ms)  COMMIT                                 
 => true                                                      
3.0.0 :008 > author.valid?
  Author Exists? (0.8ms)  SELECT 1 AS one FROM "authors" WHERE "authors"."name" = $1 AND "authors"."id" != $2 LIMIT $3  [["name", "Rahul"], ["id", 10011], ["LIMIT", 1]]
 => true                                                      
3.0.0 :009 > author.valid?(:account_setup)
  Author Exists? (0.8ms)  SELECT 1 AS one FROM "authors" WHERE "authors"."name" = $1 AND "authors"."id" != $2 LIMIT $3  [["name", "Rahul"], ["id", 10011], ["LIMIT", 1]]
 => false     
 
Strict Validations
You can also specify validations to be strict and raise ActiveModel::StrictValidationFailed when the object is invalid.
 
 Loading development environment (Rails 7.0.3)                                                  
3.0.0 :001 > Author.new.valid?
  Author Exists? (0.4ms)  SELECT 1 AS one FROM "authors" WHERE "authors"."email_address" IS NULL LIMIT $1  [["LIMIT", 1]]
/home/itsacheckmate/.rvm/gems/ruby-3.0.0/gems/activemodel-7.0.3/lib/active_model/errors.rb:323:in `add': Name can't be blank (ActiveModel::StrictValidationFailed)

class Author < ApplicationRecord
  validates :token, presence: true, uniqueness: true, strict: TokenGenerationException
end


Working with Validation Errors

The valid? and invalid? methods only provide a summary status on validity.
However you can dig deeper into each individual error by using various methods from the errors collection.

1.errors - 
This returns an instance of the class ActiveModel::Errors containing all errors, each error is represented by an ActiveModel::Error object.
3.0.0 :001 > author = Author.new
 => 
#<Author:0x0000565220b92eb8                                            
...                                                                    
3.0.0 :002 > author.valid?
  Author Exists? (1.4ms)  SELECT 1 AS one FROM "authors" WHERE "authors"."email_address" IS NULL LIMIT $1  [["LIMIT", 1]]                              
 => false                                                              
3.0.0 :003 > author.errors.full_messages
 => ["Email address is invalid", "Email address has already been taken", "Name can't be blank", "Name is too short (minimum is 3 characters)"] 

3.0.0 :004 > author = Author.new(name: "John Doe")
 => #<Author:0x0000565220a5c558 id: nil, name: "John Doe", dob: nil, gender: nil, country: nil, created_at: nil, updated_at: nil, lock_version: 0, email_address: nil> 
3.0.0 :005 > author.errors
 => #<ActiveModel::Errors []> 

2 errors[] -
errors[] is used when you want to check the error messages for a specific attribute. It returns an array of strings with all error messages for the given attribute, each string with one error message. If there are no errors related to the attribute, it returns an empty array.
Loading development environment (Rails 7.0.3)                                   
3.0.0 :001 > author = Author.new(name: "Virat Kohli")
 => #<Author:0x00007f99c4938ab8 id: nil, name: "Virat Kohli", dob: nil, gender: nil, country: nil, created_at: nil, updated_at: nil, lock_version: 0, email_address: nil> 
3.0.0 :002 > author.valid?
 => true 
3.0.0 :003 > author.errors[:name]
 => [] 
3.0.0 :004 >

3.0.0 :004 > author = Author.new(name:  "JD")
 => #<Author:0x000056376dfec360 id: nil, name: "JD", dob: nil, gender: nil, country: nil, created_at: nil, updated_at: nil, lock_version: 0, email_address: nil> 
3.0.0 :005 > author.valid?
 => false 
3.0.0 :006 > author.errors[:name]
 => ["is too short (minimum is 3 characters)"] 

3.0.0 :008 > author.valid?
 => false 
3.0.0 :009 > author.errors[:name]
 => ["can't be blank", "is too short (minimum is 3 characters)"] 

3 errors.where and error object - 
Sometimes we may need more information about each error beside its message. Each error is encapsulated as an ActiveModel::Error object, and where method is the most common way of access.
where returns an array of error objects, filtered by various degree of conditions.

3.0.0 :010 > author = Author.new
 => #<Author:0x000056376d93c650 id: nil, name: nil, dob: nil, gender: nil, country: nil, created_at: nil, updated_at: nil, lock_version: 0, email_address: nil> 
3.0.0 :011 > author.valid?
 => false 
3.0.0 :012 > author.errors.where(:name)
 => [#<ActiveModel::Error attribute=name, type=blank, options={}>, #<ActiveModel::Error attribute=name, type=too_short, options={:count=>3}>] 

3.0.0 :013 > author.errors.where(:name, :too_short)
 => [#<ActiveModel::Error attribute=name, type=too_short, options={:count=>3}>] 

You can read various information from these error objects:
3.0.0 :014 > error = author.errors.where(:name).last
 => #<ActiveModel::Error attribute=name, type=too_short, options={:count=>3}> 
3.0.0 :015 > error.attribute
 => :name 
3.0.0 :016 > error.type
 => :too_short 
3.0.0 :017 > error.options[:count]
 => 3 

You can also generate the error message:
3.0.0 :018 > error.message
 => "is too short (minimum is 3 characters)" 
3.0.0 :019 > error.full_message
 => "Name is too short (minimum is 3 characters)" 

The full_message method generates a more user-friendly message, with the capitalized attribute name prepended.

4 errors.add -
The add method creates the error object by taking the attribute, the error type and additional options hash. This is useful for writing your own validator.

validate do |author|
    errors.add :name, :too_plain, message: "please type the full name"
  end

3.0.0 :001 > author = Author.new
 => #<Author:0x000055f97baf9c70 id: nil, name: nil, dob: nil, gender: nil, country: nil, created_at: nil, updated_at: nil, lock_version: 0, email_address: nil> 
3.0.0 :002 > author.valid?
 => false 
3.0.0 :003 > author.errors.where(:name).full_message
(irb):3:in `<main>': undefined method `full_message' for [#<ActiveModel::Error attribute=name, type=too_plain, options={:message=>"please type the full name"}>]:Array (NoMethodError)
3.0.0 :004 > author.errors.where(:name).first.type
 => :too_plain 
3.0.0 :005 > author.errors.where(:name).first.full_message
 => "Name please type the full name" 
 
5 errors[:base] - 
You can add errors that are related to the object's state as a whole, instead of being related to a specific attribute. You can add errors to :base when you want to say that the object is invalid, no matter the values of its attributes.

 validate do |author|
    errors.add :base, :invalid, message: "This person is invalid because ..."
  end

3.0.0 :001 > author = Author.create
 => #<Author:0x000055ee95994038 id: nil, name: nil, dob: nil, gender: nil, country: nil, created_at: nil, updated_at: nil, lock_version: 0, email_address: nil> 
3.0.0 :002 > author.errors.where(:base).first.full_message
 => "This person is invalid because ..." 

6 errors.clear -
The clear method is used when you intentionally want to clear the errors collection. Of course, calling errors.clear upon an invalid object won't actually make it valid: the errors collection will now be empty, but the next time you call valid? or any method that tries to save this object to the database, the validations will run again. If any of the validations fail, the errors collection will be filled again.

itsacheckmate@itscheckmate:~/Training/rails/book_collection$ rails c
Loading development environment (Rails 7.0.3)                                              
3.0.0 :001 > author = Author.new
 => #<Author:0x00007f94d8a55860 id: nil, name: nil, dob: nil, gender: nil, country: nil, created_at: nil, updated_at: nil, lock_version: 0, email_address: nil> 
3.0.0 :002 > author.valid?
 => false 
3.0.0 :003 > author.errors.empty?
 => false 
3.0.0 :004 > author.errors.clear
 => [] 
3.0.0 :005 > author.errors.empty?
 => true 
3.0.0 :006 > author.save
 => false 
3.0.0 :007 > author.errors.empty?
 => false 
 
7 errors.size - 
The size method returns the total number of errors for the object.

.0.0 :008 > author = Author.new
 => #<Author:0x0000560aa9f1bd00 id: nil, name: nil, dob: nil, gender: nil, country: nil, created_at: nil, updated_at: nil, lock_version: 0, email_address: nil> 
3.0.0 :009 > author.valid?
 => false 
3.0.0 :010 > author.errors.size?
(irb):10:in `<main>': undefined method `size?' for #<ActiveModel::Errors [#<ActiveModel::Error attribute=name, type=blank, options={}>, #<ActiveModel::Error attribute=name, type=too_short, options={:count=>3}>]> (NoMethodError)                                                           
Did you mean?  size                                                                 
3.0.0 :011 > author.errors.size
 => 2 
3.0.0 :012 > author = Author.new
 => #<Author:0x0000560aaa6940c8 id: nil, name: nil, dob: nil, gender: nil, country: nil, created_at: nil, updated_at: nil, lock_version: 0, email_address: nil> 
3.0.0 :013 > author.name = "Chetan Bhagat"
 => "Chetan Bhagat" 
3.0.0 :014 > author.dob = "1980/10/11"
 => "1980/10/11" 
3.0.0 :015 > author.gender= "Male"
 => "Male" 
3.0.0 :016 > author.country = "India"
 => "India" 
3.0.0 :017 > author.email_address = "chetan@gmail.com"
 => "chetan@gmail.com" 
3.0.0 :018 > author
 => #<Author:0x0000560aaa6940c8 id: nil, name: "Chetan Bhagat", dob: Sat, 11 Oct 1980, gender: "Male", country: "India", created_at: nil, updated_at: nil, lock_version: 0, email_address: "chetan@gmail.com">                                                                   
3.0.0 :019 > author.valid?
 => true 
3.0.0 :020 > author.errors.size
 => 0 
 
Conditional Validation - 
Sometimes it will make sense to validate an object only when a given predicate is satisfied. You can do that by using the :if and :unless options, which can take a symbol, a Proc or an Array. You may use the :if option when you want to specify when the validation should happen. If you want to specify when the validation should not happen, then you may use the :unless option.

.1 Using a Symbol with :if and :unless
You can associate the :if and :unless options with a symbol corresponding to the name of a method that will get called right before validation happens. This is the most commonly used option.


5.2 Using a Proc with :if and :unless

It is possible to associate :if and :unless with a Proc object which will be called. Using a Proc object gives you the ability to write an inline condition instead of a separate method. This option is best suited for one-liners.

3.0.0 :007 > book = Book.new
 => #<Book:0x000055b98f578188 id: nil, title: nil, total_page: nil, rating: nil, price: nil, created_at: nil, updated_at: nil, date_published: nil, publisher_id: nil> 
                              
3.0.0 :001 > book = Book.new
 => #<Book:0x000055c67d3738b0 id: nil, title: nil, total_page: nil, rating: nil, price: nil, created_at: nil, updated_at: nil, date_published: nil, publisher_id: nil> 
3.0.0 :002 > book.title = "Harry Potter"
 => "Harry Potter" 
3.0.0 :003 > book.title_confirmation="Harry Potter"
 => "Harry Potter" 
3.0.0 :004 > book.valid?
 => true 


 Grouping Conditional validations

Sometimes it is useful to have multiple validations use one condition.

Loading development environment (Rails 7.0.3)
3.0.0 :001 > author = Author.new
 => 
#<Author:0x00007f229ca427a0                                            
...                                                                    
3.0.0 :002 > author.valid?
 => false 
3.0.0 :003 > author.name = "Sam"
 => "Sam" 
3.0.0 :004 > author.valid?
 => false 
3.0.0 :005 
 => {:name_confirmation=>["can't be blank"]} 


Combining Validation Conditions

For multiple conditions define whether or not a validation should happen, an Array can be used. 
Can apply both :if and :unless to the same validation.


1 Custom Validators
Custom validators are classes that inherit from ActiveModel::Validator. These classes must implement the validate method which takes a record as an argument and performs the validation on it. The custom validator is called using the validates_with method.
3.0.0 :002 > author.name = "Xavier"
 => "Xavier" 
3.0.0 :003 > author.valid?
 => true 
3.0.0 :004 > author.name = "Cavier"
 => "Cavier" 
3.0.0 :005 > author.valid?
 => false 
3.0.0 :006 > author.errors[:name]
 => ["Need a name starting with X please!"] 

The easiest way to add custom validators for validating individual attributes is with the convenient ActiveModel::EachValidator. In this case, the custom validator class must implement a validate_each method which takes three arguments: record, attribute, and value. These correspond to the instance, the attribute to be validated, and the value of the attribute in the passed instance.

3.0.0 :006 > cust.errors[:name]
 => ["is too short (minimum is 2 characters)", "Please provide full name"] 


 Custom Methods

You can also create methods that verify the state of your models and add errors to the errors collection when they are invalid. You must then register these methods by using the validate class method, passing in the symbols for the validation methods' names.

You can pass more than one symbol for each class method and the respective validations will be run in the same order as they were registered.

The valid? method will verify that the errors collection is empty, so your custom validation methods should add errors to it when you wish validation to fail

 id: nil,                                                                 
 name: "MS Dhoni",                                                        
 address: nil,                                                            
 gender: nil,                                                             
 mobile: nil,                                                             
 check_in: Tue, 10 May 2022,                                              
 check_out: nil,                                                          
 created_at: nil,                                                         
 updated_at: nil,                                           
 country: nil>                                              
3.0.0 :009 > cust.valid?
/home/itsacheckmate/Training/rails/hms/app/models/customer.rb:25:in `check_out_cannot_be_less_than_check_in': undefined method `<' for nil:NilClass (NoMethodError)
3.0.0 :010 > cust.check_out ="2022/05/09"
 => "2022/05/09" 
3.0.0 :011 > cust.valid?
 => false 
3.0.0 :012 > cust.errors.message
(irb):12:in `<main>': undefined method `message' for #<ActiveModel::Errors [#<ActiveModel::Error attribute=address_confirmation, type=blank, options={}>, #<ActiveModel::Error attribute=address, type=not_a_number, options={:message=>"%{value} seems wrong", :value=>nil}>, #<ActiveModel::Error attribute=mobile, type=wrong_length, options={:count=>10}>, #<ActiveModel::Error attribute=check_in, type=cant be in the past, options={}>, #<ActiveModel::Error attribute=check_out, type=cant be less than the check-in date, options={}>]> (NoMethodError)                                     
Did you mean?  messages                                                           
3.0.0 :013 > cust.errors.messages
 => 
{:address_confirmation=>["can't be blank"],                                       
 :address=>[" seems wrong"],                                                      
 :mobile=>["is the wrong length (should be 10 characters)"],                      
 :check_in=>["cant be in the past"],                                              
 :check_out=>["cant be less than the check-in date"]} 
 
 
